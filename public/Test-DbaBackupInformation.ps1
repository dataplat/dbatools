function Test-DbaBackupInformation {
    <#
    .SYNOPSIS
        Validates backup history objects to ensure successful database restoration

    .DESCRIPTION
        Performs comprehensive pre-restore validation on backup history objects to prevent restore failures before they occur. Input is typically from Format-DbaBackupInformation and gets parsed to verify restore readiness.

        This function runs critical validation tests including LSN chain integrity for transaction log backups, backup file accessibility by the SQL Server service account, database existence conflicts, and file path availability. It also creates necessary target directories and prevents file conflicts with existing databases.

        Use this before running Restore-DbaDatabase to catch configuration issues early, saving time during maintenance windows or disaster recovery scenarios. Validated backup sets are marked with IsVerified = $True so you can easily filter successful candidates for restoration.

        Tests performed include:
          - Checking unbroken LSN chain for transaction log backups
          - Verifying target database doesn't exist unless WithReplace is specified
          - Ensuring backup files exist and are accessible by SQL Server service account
          - Validating no file conflicts with existing databases
          - Creating required target directories for database files
          - Confirming backup files can be read from the specified locations

    .PARAMETER BackupHistory
        Backup history objects containing restore chain information, typically generated by Format-DbaBackupInformation. Each object represents a backup file with metadata needed for validation including database name, backup type, LSN values, and file paths.
        Pass the output from Format-DbaBackupInformation to validate the entire restore sequence before attempting restoration.

    .PARAMETER SqlInstance
        The Sql Server instance that wil be performing the restore

    .PARAMETER SqlCredential
        Login to the target instance using alternative credentials. Accepts PowerShell credentials (Get-Credential).

        Windows Authentication, SQL Server Authentication, Active Directory - Password, and Active Directory - Integrated are all supported.

        For MFA support, please use Connect-DbaInstance.

    .PARAMETER WithReplace
        Allows restoration over an existing database with the same name. Without this switch, validation fails if the target database already exists on the destination instance.
        Use this when performing disaster recovery or refresh scenarios where you need to replace the current database with backup data.

    .PARAMETER Continue
        Indicates this is a continuation of an existing restore operation, typically used when applying additional transaction log backups. Skips LSN chain validation and allows restoration to databases that already exist in RESTORING state.
        Use this when performing point-in-time recovery scenarios where you're applying additional log backups after an initial restore.

    .PARAMETER OutputScriptOnly
        Prevents automatic creation of missing target directories during validation. Missing paths generate warnings instead of being created automatically.
        Use this for testing restore scenarios without making changes to the file system, or when you need to verify permissions before allowing directory creation.

    .PARAMETER EnableException
        By default, when something goes wrong we try to catch it, interpret it and give you a friendly warning message.
        This avoids overwhelming you with "sea of red" exceptions, but is inconvenient because it basically disables advanced scripting.
        Using this switch turns this "nice by default" feature off and enables you to catch exceptions with your own try/catch.

    .PARAMETER VerifyOnly
        Performs limited validation focusing only on backup file accessibility and readability. Skips database existence checks, file path conflicts, and directory creation since no actual restore will occur.
        Use this when you only need to verify that backup files are valid and accessible without testing restore feasibility to the target instance.

    .PARAMETER WhatIf
        Shows what would happen if the cmdlet runs. The cmdlet is not run.

    .PARAMETER Confirm
        Prompts you for confirmation before running the cmdlet.

    .NOTES
        Tags: Backup, Restore, DisasterRecovery
        Author: Stuart Moore (@napalmgram), stuart-moore.com

        Website: https://dbatools.io
        Copyright: (c) 2018 by dbatools, licensed under MIT
        License: MIT https://opensource.org/licenses/MIT

    .LINK
        https://dbatools.io/Test-DbaBackupInformation

    .EXAMPLE
        PS C:\> $BackupHistory | Test-DbaBackupInformation -SqlInstance MyInstance
        PS C:\> $PassedDbs = $BackupHistory | Where-Object {$_.IsVerified -eq $True}
        PS C:\> $FailedDbs = $BackupHistory | Where-Object {$_.IsVerified -ne $True}

        Pass in a BackupHistory object to be tested against MyInstance.
        Those records that pass are marked as verified. We can then use the IsVerified property to divide the failures and successes

    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = "Low")]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseOutputTypeCorrectly", "", Justification = "PSSA Rule Ignored by BOH")]
    param (
        [parameter(Mandatory, ValueFromPipeline)]
        [object[]]$BackupHistory,
        [DbaInstanceParameter]$SqlInstance,
        [PSCredential]$SqlCredential,
        [switch]$WithReplace,
        [switch]$Continue,
        [switch]$VerifyOnly,
        [switch]$OutputScriptOnly,
        [switch]$EnableException
    )

    begin {
        try {
            $RestoreInstance = Connect-DbaInstance -SqlInstance $SqlInstance -SqlCredential $SqlCredential
        } catch {
            Stop-Function -Message "Failure" -Category ConnectionError -ErrorRecord $_ -Target $SqlInstance
            return
        }
        $InternalHistory = @()
    }
    process {
        if (Test-FunctionInterrupt) { return }

        foreach ($bh in $BackupHistory) {
            $InternalHistory += $bh
        }
    }
    end {
        if (Test-FunctionInterrupt) { return }

        $RegisteredFileCheck = Get-DbaDbPhysicalFile -SqlInstance $RestoreInstance

        $Databases = $InternalHistory.Database | Select-Object -Unique
        foreach ($Database in $Databases) {
            $VerificationErrors = 0
            Write-Message -Message "Testing restore for $Database" -Level Verbose
            #Test we're only restoring backups from one database, or hilarity will ensure
            $DbHistory = $InternalHistory | Where-Object { $_.Database -eq $Database }
            if (( $DbHistory | Sort-Object -Property OriginalDatabase -Unique ).Count -gt 1) {
                Write-Message -Message "Trying to restore $Database from multiple sources databases" -Level Warning
                $VerificationErrors++
            }
            #Test Db Existance on destination
            $DbCheck = Get-DbaDatabase -SqlInstance $RestoreInstance -Database $Database
            # Only do file and db tests if we're not verifing
            Write-Message -Level Verbose -Message "VerifyOnly = $VerifyOnly"
            If ($VerifyOnly -ne $true) {
                if ($null -ne $DbCheck -and ($WithReplace -ne $true -and $Continue -ne $true)) {
                    Write-Message  -Level Warning -Message "Database $Database exists, so WithReplace must be specified" -Target $database
                    $VerificationErrors++
                }

                $DBFileCheck = ($RegisteredFileCheck | Where-Object Name -eq $Database).PhysicalName
                $OtherFileCheck = ($RegisteredFileCheck | Where-Object Name -ne $Database).PhysicalName
                $DBHistoryPhysicalPaths = ($DbHistory | Select-Object -ExpandProperty filelist | Select-Object PhysicalName -Unique).PhysicalName
                $DBHistoryPhysicalPathsTest = Test-DbaPath -SqlInstance $RestoreInstance -Path $DBHistoryPhysicalPaths
                $DBHistoryPhysicalPathsExists = ($DBHistoryPhysicalPathsTest | Where-Object FileExists -eq $True).FilePath
                $pathSep = Get-DbaPathSep -Server $RestoreInstance
                foreach ($path in $DBHistoryPhysicalPaths) {
                    if (($DBHistoryPhysicalPathsTest | Where-Object FilePath -eq $path).FileExists) {
                        if ($path -in $DBFileCheck) {
                            #If the Files are owned by the db we're restoring check for Continue or WithReplace. If not, then report error otherwise just carry on
                            if ($WithReplace -ne $True -and $Continue -ne $True) {
                                Write-Message -Message "File $path already exists on $SqlInstance and WithReplace not specified, cannot restore" -Level Warning
                                $VerificationErrors++
                            }
                        } elseif ($path -in $OtherFileCheck) {
                            Write-Message -Message "File $path already exists on $SqlInstance and owned by another database, cannot restore" -Level Warning
                            $VerificationErrors++
                        } elseif ($path -in $DBHistoryPhysicalPathsExists -and $RestoreInstance.VersionMajor -gt 8) {
                            Write-Message -Message "File $path already exists on $($SqlInstance.ComputerName), not owned by any database in $SqlInstance, will not overwrite." -Level Warning
                            $VerificationErrors++
                        }
                    } else {
                        <#
                        dang, Split-Path converts path separators always using the "current system" settings
                        PS C:> Split-Path -Path '/var/opt/mssql/data/foo.bak' -Parent
                        \var\opt\mssql\data
                        I'm not aware of a safe way to change this so...we do a little hack.
                        #>
                        $pathSep = Get-DbaPathSep -Server $RestoreInstance
                        $ParentPath = Split-Path $path -Parent
                        $ParentPath = $ParentPath.Replace('\', $pathSep)
                        if (!(Test-DbaPath -SqlInstance $RestoreInstance -Path $ParentPath) ) {
                            if (-not $OutputScriptOnly) {
                                $ConfirmMessage = "`n Creating Folder $ParentPath on $SqlInstance `n"
                                if ($Pscmdlet.ShouldProcess("$Path on $SqlInstance `n `n", $ConfirmMessage)) {
                                    if (New-DbaDirectory -SqlInstance $RestoreInstance -Path $ParentPath) {
                                        Write-Message -Message "Created Folder $ParentPath on $SqlInstance" -Level Verbose
                                    } else {
                                        Write-Message -Message "Failed to create $ParentPath on $SqlInstance" -Level Warning
                                        $VerificationErrors++
                                    }
                                }
                            } else {
                                Write-Message -Message "Parth $ParentPath on $SqlInstance does not exist" -Level Verbose
                            }
                        }
                    }
                }
                #Test for LSN chain
                if ($true -ne $Continue) {
                    if (!($DbHistory | Test-DbaLsnChain)) {
                        Write-Message -Message "LSN Check failed" -Level Verbose
                        $VerificationErrors++
                    }
                }
            }

            #Test all backups readable
            $allpaths = $DbHistory | Select-Object -ExpandProperty FullName
            $allpaths_validity = Test-DbaPath -SqlInstance $RestoreInstance -Path $allpaths
            foreach ($path in $allpaths_validity) {
                if ($path.FileExists -eq $false -and ($path.FilePath -notlike 'http*')) {
                    Write-Message -Message "Backup File $($path.FilePath) cannot be read by $($RestoreInstance.Name). Does the service account ($($RestoreInstance.ServiceAccount)) have permission?" -Level Warning
                    $VerificationErrors++
                }
            }

            if ($VerificationErrors -eq 0) {
                Write-Message -Message "Marking $Database as verified" -Level Verbose
                $InternalHistory | Where-Object { $_.Database -eq $Database } | ForEach-Object { $_.IsVerified = $True }
            } else {
                Write-Message -Message "Verification errors  = $VerificationErrors - Has not Passed" -Level Verbose
            }
        }
        $InternalHistory
    }
}