function Copy-DbaDatabase {
	<#
		.SYNOPSIS
			Migrates Sql Server databases from one Sql Server to another.

		.DESCRIPTION
			This script provides the ability to migrate databases using detach/copy/attach or backup/restore. This script works with named instances, clusters and Sql Express.

			By default, databases will be migrated to the destination Sql Server's default data and log directories. You can override this by specifying -ReuseSourceFolderStructure. Filestreams and filegroups are also migrated. Safety is emphasized.

		.PARAMETER Source
			Source SQL Server.You must have sysadmin access and server version must be SQL Server version 2000 or greater.

		.PARAMETER SourceSqlCredential
			Allows you to login to servers using SQL Logins as opposed to Windows Auth/Integrated/Trusted. To use:F

			$scred = Get-Credential, this pass $scred object to the param.

			Windows Authentication will be used if DestinationSqlCredential is not specified. To connect as a different Windows user, run PowerShell as that user.

		.PARAMETER Destination
			Destination Sql Server. You must have sysadmin access and server version must be SQL Server version 2000 or greater.

		.PARAMETER DestinationSqlCredential
			Allows you to login to servers using SQL Logins as opposed to Windows Auth/Integrated/Trusted. To use:

			$dcred = Get-Credential, this pass this $dcred to the param.

			Windows Authentication will be used if DestinationSqlCredential is not specified. To connect as a different Windows user, run PowerShell as that user.

		.PARAMETER Database
			Migrates ONLY specified databases. This list is auto-populated for tab completion. Multiple databases are allowed.

		.PARAMETER ExcludeDatabase
			Excludes specified databases when performing -AllDatabases migrations. This list is auto-populated for tab completion.

		.PARAMETER AllDatabases
			This is a parameter that was included for safety, so you don't accidentally detach/attach all databases without specifying. Migrates user databases. Does not migrate system or support databases. Requires -BackupRestore or -DetachAttach.

		.PARAMETER BackupRestore
			Use the a Copy-Only Backup and Restore Method. This parameter requires that you specify -NetworkShare in a valid UNC format (\\server\share)

			Backups will be immediately deleted after use unless -NoBackupCleanup is specified.

		.PARAMETER NetworkShare
			Specifies the network location for the backup files. The Sql Service service accounts must read/write permission to access this location.

		.PARAMETER WithReplace
			It's exactly WITH REPLACE. This is useful if you want to stage some complex file paths.

		.PARAMETER NoRecovery
			Sets restore to NoRecovery. Ideal for staging.

		.PARAMETER NoBackupCleanup
			By default, backups generated by the module will be deleted immediately after they are restored. Use this to skip.

		.PARAMETER NumberFiles
			Number of files to split the backup. Default is 3.

		.PARAMETER DetachAttach
			Uses the detach/copy/attach method to perform database migrations. No files are deleted on the source. If the destination attachment fails, the source database will be reattached. File copies are performed over administrative shares (\\server\x$\mssql) using BITS. If a database is being mirrored, the mirror will be broken prior to migration.

		.PARAMETER Reattach
			Reattaches all source databases after DetachAttach migration.

		.PARAMETER SetSourceReadOnly
			Sets all migrated databases to ReadOnly prior to detach/attach & backup/restore. If -Reattach is used, db is set to read-only after reattach.

		.PARAMETER ReuseSourceFolderStructure
			By default, databases will be migrated to the destination Sql Server's default data and log directories. You can override this by specifying -ReuseSourceFolderStructure.
			The same structure on the SOURCE will be kept exactly, so consider this if you're migrating between different versions and use part of Microsoft's default Sql structure (MSSql12.INSTANCE, etc)

			* note, to reuse destination folder structure, specify -WithReplace

		.PARAMETER IncludeSupportDbs
			Migration of ReportServer, ReportServerTempDb, SSIDb, and distribution databases if they exist. A logfile named $SOURCE-$DESTINATION-$date-Sqls.csv will be written to the current directory. Requires -BackupRestore or -DetachAttach.

		.PARAMETER DatabaseCollection
			Takes dbobject from pipeline

		.PARAMETER NoCopyOnly
			By default, Copy-DbaDatabase backups are backed up with COPY_ONLY, which avoids breaking the LSN backup chain. This parameter will set CopyOnly to $false.

		.PARAMETER SetSourceOffline
			Sets the Source db to offline after copy

		.PARAMETER WhatIf
			Shows what would happen if the command were to run. No actions are actually performed.

		.PARAMETER Confirm
			Prompts you for confirmation before executing any changing operations within the command.

		.PARAMETER Force
			Drops existing databases with matching names. If using -DetachAttach, -Force will break mirrors and drop dbs from Availability Groups.

		.PARAMETER Silent
			Use this switch to disable any kind of verbose messages

		.NOTES
			Tags: Migration, DisasterRecovery, Backup, Restore
			Original Author: Chrissy LeMaire (@cl), netnerds.net
			Requires: sysadmin access on SQL Servers
			Limitations: Doesn't cover what it doesn't cover (replication, certificates, etc)
						Sql Server 2000 databases cannot be directly migrated to Sql Server 2012 and above.
						Logins within Sql Server 2012 and above logins cannot be migrated to Sql Server 2008 R2 and below.

			Website: https://dbatools.io
			Copyright: (C) Chrissy LeMaire, clemaire@gmail.com
			License: GNU GPL v3 https://opensource.org/licenses/GPL-3.0

		.LINK
			https://dbatools.io/Copy-DbaDatabase

		.EXAMPLE
			Copy-DbaDatabase -Source sqlserver2014a -Destination sqlserver2014b -Database TestDB -BackupRestore -NetworkShare \\fileshare\sql\migration

			Migrates a single user database TestDB using Backup and restore from instance sqlserver2014a to sqlserver2014b. Backup files are stored in \\fileshare\sql\migration.

		.EXAMPLE
			Copy-DbaDatabase -Source sqlserver2014a -Destination sqlcluster -DetachAttach -Reattach

			Databases will be migrated from sqlserver2014a to sqlcluster using the detach/copy files/attach method.The following will be perfomed: kick all users out of the database, detach all data/log files, move files across the network over an admin share (\\SqlSERVER\M$\MSSql...), attach file on destination server, reattach at source. If the database files (*.mdf, *.ndf, *.ldf) on *destination* exist and aren't in use, they will be overwritten.

		.EXAMPLE
			Copy-DbaDatabase -Source sqlserver2014a -Destination sqlcluster -ExcludeDatabase Northwind, pubs -IncludeSupportDbs -Force -BackupRestore -NetworkShare \\fileshare\sql\migration

			Migrates all user databases except for Northwind and pubs by using backup/restore (copy-only). Backup files are stored in \\fileshare\sql\migration. If the database exists on the destination, it will be dropped prior to attach.

			It also includes the support databases (ReportServer, ReportServerTempDb, distribution).
	#>
	[CmdletBinding(DefaultParameterSetName = "DbBackup", SupportsShouldProcess = $true)]
	Param (
		[parameter(Mandatory = $false)]
		[DbaInstanceParameter]$Source,
		[PSCredential][System.Management.Automation.CredentialAttribute()]
		$SourceSqlCredential,
		[parameter(Mandatory = $true)]
		[DbaInstanceParameter]$Destination,
		[PSCredential][System.Management.Automation.CredentialAttribute()]
		$DestinationSqlCredential,
		[Alias("Databases")]
		[object[]]$Database,
		[object[]]$ExcludeDatabase,
		[Alias("All")]
		[parameter(ParameterSetName = "DbBackup")]
		[parameter(ParameterSetName = "DbAttachDetach")]
		[switch]$AllDatabases,
		[parameter(Mandatory = $true, ParameterSetName = "DbBackup")]
		[switch]$BackupRestore,
		[parameter(Mandatory = $true, ParameterSetName = "DbBackup",
			HelpMessage = "Specify a valid network share in the format \\server\share that can be accessed by your account and both Sql Server service accounts.")]
		[string]$NetworkShare,
		[parameter(ParameterSetName = "DbBackup")]
		[switch]$WithReplace,
		[parameter(ParameterSetName = "DbBackup")]
		[switch]$NoRecovery,
		[parameter(ParameterSetName = "DbBackup")]
		[switch]$NoBackupCleanup,
		[parameter(ParameterSetName = "DbBackup")]
		[ValidateRange(1, 64)]
		[int]$NumberFiles = 3,
		[parameter(Mandatory = $true, ParameterSetName = "DbAttachDetach")]
		[switch]$DetachAttach,
		[parameter(ParameterSetName = "DbAttachDetach")]
		[switch]$Reattach,
		[parameter(ParameterSetName = "DbBackup")]
		[parameter(ParameterSetName = "DbAttachDetach")]
		[switch]$SetSourceReadOnly,
		[Alias("ReuseFolderstructure")]
		[parameter(ParameterSetName = "DbBackup")]
		[parameter(ParameterSetName = "DbAttachDetach")]
		[switch]$ReuseSourceFolderStructure,
		[parameter(ParameterSetName = "DbBackup")]
		[parameter(ParameterSetName = "DbAttachDetach")]
		[switch]$IncludeSupportDbs,
		[parameter(ValueFromPipeline = $True)]
		[object]$DatabaseCollection,
		[switch]$NoCopyOnly,
		[switch]$SetSourceOffline,
		[switch]$Force,
		[switch]$Silent
	)

	begin {
		# Global Database Function
		function Get-SqlFileStructure {
			$dbcollection = @{ };
			$databaseProgressbar = 0

			foreach ($db in $databaseList) {
				Write-Progress -Id 1 -Activity "Processing database file structure" -PercentComplete ($databaseProgressbar / $dbCount * 100) -Status "Processing $databaseProgressbar of $dbCount"
				$dbName = $db.Name
				Write-Message -Level Verbose -Message $dbName

				$databaseProgressbar++
				$dbStatus = $db.status.toString()
				if ($dbStatus.StartsWith("Normal") -eq $false) { continue }
				$destinationfiles = @{ }; $sourcefiles = @{ }

				$where = "Filetype <> 'LOG' and Filetype <> 'FULLTEXT'"

				$datarows = $dbFileTable.Tables.Select("dbname = '$dbName' and $where")

				# Data Files
				foreach ($file in $datarows) {
					# Destination File Structure
					$d = @{ }
					if ($ReuseSourceFolderStructure) {
						$d.physical = $file.filename
					}
					elseif ($WithReplace) {
						$name = $file.Name
						$destfile = $remoteDbFileTable.Tables[0].Select("dbname = '$dbName' and name = '$name'")
						$d.physical = $destfile.filename

						if ($null -eq $d.physical) {
							$directory = Get-SqlDefaultPaths $destServer data
							$fileName = Split-Path $file.filename -Leaf
							$d.physical = "$directory\$fileName"
						}
					}
					else {
						$directory = Get-SqlDefaultPaths $destServer data
						$fileName = Split-Path $file.filename -Leaf
						$d.physical = "$directory\$fileName"
					}
					$d.logical = $file.Name

					$d.remotefilename = Join-AdminUNC $destNetBios $d.physical
					$destinationfiles.add($file.Name, $d)

					# Source File Structure
					$s = @{ }
					$s.logical = $file.Name
					$s.physical = $file.filename
					$s.remotefilename = Join-AdminUNC $sourceNetBios $s.physical
					$sourcefiles.add($file.Name, $s)
				}

				# Add support for Full Text Catalogs in Sql Server 2005 and below
				if ($sourceServer.VersionMajor -lt 10) {
					try {
						$fttable = $null = $sourceServer.Databases[$dbName].ExecuteWithResults('sp_help_fulltext_catalogs')
						$allrows = $fttable.Tables[0].rows
					}
					catch {
						# Nothing, it's just not enabled
					}

					foreach ($ftc in $allrows) {
						# Destination File Structure
						$d = @{ }
						$pre = "sysft_"
						$name = $ftc.Name
						$physical = $ftc.Path # RootPath
						$logical = "$pre$name"
						if ($ReuseSourceFolderStructure) {
							$d.physical = $physical
						}
						else {
							$directory = Get-SqlDefaultPaths $destServer data
							if ($destServer.VersionMajor -lt 10) { $directory = "$directory\FTDATA" }
							$fileName = Split-Path($physical) -leaf
							$d.physical = "$directory\$fileName"
						}
						$d.logical = $logical
						$d.remotefilename = Join-AdminUNC $destNetBios $d.physical
						$destinationfiles.add($logical, $d)

						# Source File Structure
						$s = @{ }
						$pre = "sysft_"
						$name = $ftc.Name
						$physical = $ftc.Path # RootPath
						$logical = "$pre$name"

						$s.logical = $logical
						$s.physical = $physical
						$s.remotefilename = Join-AdminUNC $sourceNetBios $s.physical
						$sourcefiles.add($logical, $s)
					}
				}

				$where = "Filetype = 'LOG'"
				$datarows = $dbFileTable.Tables[0].Select("dbname = '$dbName' and $where")

				# Log Files
				foreach ($file in $datarows) {
					$d = @{ }
					if ($ReuseSourceFolderStructure) {
						$d.physical = $file.filename
					}
					elseif ($WithReplace) {
						$name = $file.Name
						$destfile = $remoteDbFileTable.Tables[0].Select("dbname = '$dbName' and name = '$name'")
						$d.physical = $destfile.filename

						if ($null -eq $d.physical) {
							$directory = Get-SqlDefaultPaths $destServer data
							$fileName = Split-Path $file.filename -Leaf
							$d.physical = "$directory\$fileName"
						}
					}
					else {
						$directory = Get-SqlDefaultPaths $destServer log
						$fileName = Split-Path $file.filename -Leaf
						$d.physical = "$directory\$fileName"
					}
					$d.logical = $file.Name
					$d.remotefilename = Join-AdminUNC $destNetBios $d.physical
					$destinationfiles.add($file.Name, $d)

					$s = @{ }
					$s.logical = $file.Name
					$s.physical = $file.filename
					$s.remotefilename = Join-AdminUNC $sourceNetBios $s.physical
					$sourcefiles.add($file.Name, $s)
				}

				$location = @{ }
				$location.add("Destination", $destinationfiles)
				$location.add("Source", $sourcefiles)
				$dbcollection.Add($($db.Name), $location)
			}

			$fileStructure = [pscustomobject]@{ "databases" = $dbcollection }
			Write-Progress -id 1 -Activity "Processing database file structure" -Status "Completed" -Completed
			return $fileStructure
		}

		# Detach Attach
		function Dismount-SqlDatabase {
			[CmdletBinding()]
			param (
				[object]$server,
				[string]$dbName
			)

			$smoDb = $server.databases[$dbName]
			if ($smoDb.IsMirroringEnabled) {
				try {
					Write-Message -Level Warning -Message "Breaking mirror for $dbName"
					$smoDb.ChangeMirroringState([Microsoft.SqlServer.Management.Smo.MirroringOption]::Off)
					$smoDb.Alter()
					$smoDb.Refresh()
					Write-Message -Level Warning -Message "Could not break mirror for $dbName. Skipping."
				}
				catch {
					Stop-Function -Message "Issue breaking mirror." -Target $dbName -ErrorRecord $_
					return $false
				}
			}

			if ($smoDb.AvailabilityGroupName.Length -gt 0) {
				$agName = $smoDb.AvailabilityGroupName
				Write-Message -Level Verbose -Message "Attempting remove from Availability Group $agName"
				try {
					$server.AvailabilityGroups[$smoDb.AvailabilityGroupName].AvailabilityDatabases[$dbName].Drop()
					Write-Message -Level Verbose -Message "Successfully removed $dbName from  detach from $agName on $($server.Name)"
				}
				catch {
					Stop-Function -Message "Could not remove $dbName from $agName on $($server.Name)" -Target $dbName -ErrorRecord $_
					return $false
				}
			}

			Write-Message -Level Verbose -Message "Attempting detach from $dbName from $source"

			####### Using Sql to detach does not modify the $smoDb collection #######

			$server.KillAllProcesses($dbName)

			try {
				$sql = "ALTER DATABASE [$dbName] SET SINGLE_USER WITH ROLLBACK IMMEDIATE"
				Write-Message -Level Verbose -Message $sql
				$null = $server.ConnectionContext.ExecuteNonQuery($sql)
				Write-Message -Level Verbose -Message "Successfully set $dbName to single-user from $source"
			}
			catch {
				Stop-Function -Message "Issue setting database to single-user." -Target $dbName -ErrorRecord $_
			}

			try {
				$sql = "EXEC master.dbo.sp_detach_db N'$dbName'"
				Write-Message -Level Verbose -Message $sql
				$null = $server.ConnectionContext.ExecuteNonQuery($sql)
				Write-Message -Level Verbose -Message "Successfully detached $dbName from $source"
			}
			catch {
				Stop-Function -Message "Issue detaching database" -Target $dbName -ErrorRecord $_
			}

		}

		function Mount-SqlDatabase {
			[CmdletBinding()]
			param (
				[object]$server,
				[string]$dbName,
				[object]$fileStructure,
				[string]$dbOwner
			)

			if ($server.Logins.Item($dbOwner) -eq $null) {
				try {
					$dbOwner = ($destServer.logins | Where-Object { $_.id -eq 1 }).Name
				}
				catch {
					$dbOwner = "sa"
				}
			}
			try {
				$null = $server.AttachDatabase($dbName, $fileStructure, $dbOwner, [Microsoft.SqlServer.Management.Smo.AttachOptions]::None)
				return $true
			}
			catch {
				Stop-Function -Message "Issue mounting database." -ErrorRecord $_
				return $false
			}
		}

		function Start-SqlFileTransfer {
			<#

			SYNOPSIS
			Internal function. Uses BITS to transfer detached files (.mdf, .ndf, .ldf, and filegroups) to
			another server over admin UNC paths. Locations of data files are kept in the
			custom object generated by Get-SqlFileStructure

			#>
			param (
				[object]$fileStructure,
				[string]$dbName
			)

			$copydb = $fileStructure.databases[$dbName]
			$dbsource = $copydb.source
			$dbdestination = $copydb.destination

			foreach ($file in $dbsource.keys) {
				$remotefilename = $dbdestination[$file].remotefilename
				$from = $dbsource[$file].remotefilename
				try {
					if (Test-Path $from -pathtype container) {
						$null = New-Item -ItemType Directory -Path $remotefilename -Force
						Start-BitsTransfer -Source "$from\*.*" -Destination $remotefilename

						$directories = (Get-ChildItem -recurse $from | Where-Object { $_.PsIsContainer }).FullName
						foreach ($directory in $directories) {
							$newdirectory = $directory.replace($from, $remotefilename)
							$null = New-Item -ItemType Directory -Path $newdirectory -Force
							Start-BitsTransfer -Source "$directory\*.*" -Destination $newdirectory
						}
					}
					else {
						Write-Host "Copying $fn for $dbName"
						Start-BitsTransfer -Source $from -Destination $remotefilename
					}
					$fn = Split-Path $($dbdestination[$file].physical) -leaf
				}
				catch {
					try {
						# Sometimes BITS trips out temporarily on cloned drives.
						Start-BitsTransfer -Source $from -Destination $remotefilename
					}
					catch {
						Write-Message -Level Warning -Message "Start-BitsTransfer did not succeed. Now attempting with Copy-Item - no progress bar will be shown."
						try {
							Copy-Item -Path $from -Destination $remotefilename -ErrorAction Stop
						}
						catch {
							Write-Message -Level Warning -Message "Access denied. This can happen for a number of reasons including issues with cloned disks."
							Stop-Function -Message "Alternatively, you may need to run PowerShell as Administrator, especially when running on localhost." -Target $from -ErrorRecord $_
							return
						}
					}
				}
			}
			return $true
		}

		function Start-SqlDetachAttach {
			<#

			.SYNOPSIS
			Internal function. Performs checks, then executes Dismount-SqlDatabase on a database, copies its files to the new server,
			then performs Mount-SqlDatabase. $sourceServer and $destServer are SMO server objects.
			$fileStructure is a custom object generated by Get-SqlFileStructure

			#>
			[CmdletBinding()]
			param (
				[object]$sourceServer,
				[object]$destServer,
				[object]$fileStructure,
				[string]$dbName
			)

			$destfilestructure = New-Object System.Collections.Specialized.StringCollection
			$sourceFileStructure = New-Object System.Collections.Specialized.StringCollection
			$dbOwner = $sourceServer.databases[$dbName].owner

			if ($dbOwner -eq $null) {
				try {
					$dbOwner = ($destServer.logins | Where-Object { $_.id -eq 1 }).Name
				}
				catch {
					$dbOwner = "sa"
				}
			}

			foreach ($file in $fileStructure.databases[$dbName].destination.values) { $null = $destfilestructure.add($file.physical) }
			foreach ($file in $fileStructure.databases[$dbName].source.values) { $null = $sourceFileStructure.add($file.physical) }

			$detachresult = Dismount-SqlDatabase $sourceServer $dbName

			if ($detachresult) {

				$transfer = Start-SqlFileTransfer $fileStructure $dbName
				if ($transfer -eq $false) { Write-Warning "Could not copy files."; return "Could not copy files." }
				$attachresult = Mount-SqlDatabase $destServer $dbName $destfilestructure $dbOwner

				if ($attachresult -eq $true) {
					# add to added dbs because ATTACH was successful
					Write-Message -Level Verbose -Message "Successfully attached $dbName to $destination"
					return $true
				}
				else {
					# add to failed because ATTACH was unsuccessful
					Write-Message -Level Warning -Message "Could not attach $dbName."
					return "Could not attach database."
				}
			}
			else {
				# add to failed because DETACH was unsuccessful
				Write-Message -Level Warning -Message "Could not detach $dbName."
				return "Could not detach database."
			}
		}

	}
	process {
		if (($AllDatabases -or $IncludeSupportDbs -or $Database) -and !$DetachAttach -and !$BackupRestore) {
			Stop-Function -Message "You must specify -DetachAttach or -BackupRestore when migrating databases."
			return
		}

		if ($DatabaseCollection.Length -gt 0) {
			$Source = $DatabaseCollection[0].Parent.Name
			$Database = $DatabaseCollection.Name
		}

		if ($Database -contains "master" -or $Database -contains "msdb" -or $Database -contains "tempdb") {
			Stop-Function -Message "Migrating system databases is not currently supported."
			return
		}

		if (!$AllDatabases -and !$IncludeSupportDbs -and !$Database) {
			Stop-Function -Message "You must specify a -AllDatabases or -Database to continue."
			return
		}

		Write-Message -Level Verbose -Message "Attempting to connect to Sql Servers.."
		$sourceServer = Connect-SqlInstance -SqlInstance $Source -SqlCredential $SourceSqlCredential
		$destServer = Connect-SqlInstance -SqlInstance $Destination -SqlCredential $DestinationSqlCredential

		$destVersionLower = $destServer.VersionMajor -lt $sourceServer.VersionMajor
		$destVersionMinorLow = ($destServer.VersionMajor -eq 10 -and $sourceServer.VersionMajor -eq 10) -and ($destServer.VersionMinor -lt $sourceServer.VersionMinor)
		if ($destVersionLower -or $destVersionMinorLow) {
			Stop-Function -Message "Error: copy database cannot be made from newer $($sourceServer.VersionString) to older $($destServer.VersionString) SQL Server version"
			return
		}

		if ($DetachAttach) {
			if ($sourceServer.NetName -eq $env:COMPUTERNAME -or $destServer.NetName -eq $env:COMPUTERNAME) {
				if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
					Write-Message -Level Warning -Message "When running DetachAttach locally on the console, it's likely you'll need to Run As Administrator. Trying anyway."
				}
			}
		}

		$source = $sourceServer.DomainInstanceName
		$destination = $destServer.DomainInstanceName

		if ($NetworkShare.Length -gt 0) {
			if ($(Test-DbaSqlPath -SqlInstance $sourceServer -Path $NetworkShare) -eq $false) {
				Write-Message -Level Warning -Message "$Source may not be able to access $NetworkShare. Trying anyway."
			}

			if ($(Test-DbaSqlPath -SqlInstance $destServer -Path $NetworkShare) -eq $false) {
				Write-Message -Level Warning -Message "$Destination may not be able to access $NetworkShare. Trying anyway."
			}

			if ($NetworkShare.StartsWith('\\')) {
				try {
					$shareServer = ($NetworkShare -split "\\")[2]
					$hostEntry = ([Net.Dns]::GetHostEntry($shareServer)).HostName -split "\."

					if ($shareServer -ne $hostEntry[0]) {
						Write-Message -Level Warning -Message "Using CNAME records for the network share may present an issue if an SPN has not been created. Trying anyway. If it doesn't work, use a different (A record) hostname."
					}
				}
				catch {
					Stop-Function -Message "Error validating unc path: $_"
					return
				}
			}
		}

		Write-Message -Level Verbose -Message "Resolving NetBIOS names"
		$sourceNetBios = Resolve-NetBiosName $sourceServer
		$destNetBios = Resolve-NetBiosName $destServer

		Write-Message -Level Verbose -Message "Performing SMO version check"
		Invoke-SmoCheck -SqlInstance $sourceServer
		Invoke-SmoCheck -SqlInstance $destServer

		Write-Message -Level Verbose -Message "Checking to ensure the source isn't the same as the destination"
		if ($source -eq $destination) {
			Stop-Function -Message "Source and Destination Sql Servers instances are the same. Quitting."
			return
		}

		if ($NetworkShare.Length -gt 0) {
			Write-Message -Level Verbose -Message "Checking to ensure network path is valid"
			if (!($NetworkShare.StartsWith("\\"))) {
				Stop-Function -Message "Network share must be a valid UNC path (\\server\share)."
				return
			}

			try {
				if (Test-Path $NetworkShare -ErrorAction Stop) {
					Write-Message -Level Verbose -Message "$NetworkShare share can be accessed."
				}
			}
			catch {
				Write-Message -Level Warning -Message "$NetworkShare share cannot be accessed. Still trying anyway, in case the SQL Server service accounts have access."
			}
		}

		Write-Message -Level Verbose -Message "Checking to ensure server is not SQL Server 7 or below"
		if ($sourceServer.VersionMajor -lt 8 -and $destServer.VersionMajor -lt 8) {
			Stop-Function -Message "This script can only be run on Sql Server 2000 and above. Quitting."
			return
		}

		Write-Message -Level Verbose -Message "Checking to ensure detach/attach is not attempted on SQL Server 2000"
		if ($destServer.VersionMajor -lt 9 -and $DetachAttach) {
			Stop-Function -Message "Detach/Attach not supported when destination Sql Server is version 2000. Quitting."
			return
		}

		Write-Message -Level Verbose -Message "Checking to ensure SQL Server 2000 migration isn't directly attempted to SQL Server 2012"
		if ($sourceServer.VersionMajor -lt 9 -and $destServer.VersionMajor -gt 10) {
			Stop-Function -Message "Sql Server 2000 databases cannot be migrated to Sql Server versions 2012 and above. Quitting."
			return
		}

		Write-Message -Level Verbose -Message "Warning if migration from 2005 to 2012 and above and attach/detach is used."
		if ($sourceServer.VersionMajor -eq 9 -and $destServer.VersionMajor -gt 9 -and !$BackupRestore -and !$Force -and $DetachAttach) {
			Stop-Function -Message "Backup and restore is the safest method for migrating from Sql Server 2005 to other Sql Server versions. Please use the -BackupRestore switch or override this requirement by specifying -Force."
			return
		}

		if ($sourceServer.Collation -ne $destServer.Collation) {
			Write-Message -Level Verbose -Message "Warning on different collation"
			Write-Message -Level Warning -Message "Collation on $Source, $($sourceServer.Collation) differs from the $Destination, $($destServer.Collation)."
		}

		Write-Message -Level Verbose -Message "Ensuring user databases exist (counting databases)"
		$dbTotal = $sourceServer.Databases.Count

		if ($dbTotal -le 4) {
			Stop-Function -Message "No user databases to migrate. Quitting."
		}

		Write-Message -Level Verbose -Message "Ensuring destination server version is equal to or greater than source"
		if ([version]$sourceServer.ResourceVersionString -gt [version]$destServer.ResourceVersionString) {
			Stop-Function -Message "Source Sql Server version build must be <= destination Sql Server for database migration."
		}

		# SMO's filestreamlevel is sometimes null
		$sql = "select coalesce(SERVERPROPERTY('FilestreamConfiguredLevel'),0) as fs"
		$sourceFilestream = $sourceServer.ConnectionContext.ExecuteScalar($sql)
		$destFilestream = $destServer.ConnectionContext.ExecuteScalar($sql)
		if ($sourceFilestream -gt 0 -and $destFilestream -eq 0) {
			$fsWarning = $true
		}

		Write-Message -Level Verbose -Message "Writing warning about filestream being enabled"
		if ($fsWarning) {
			Write-Message -Level Warning -Message "FILESTREAM enabled on $source but not $destination. Databases that use FILESTREAM will be skipped."
		}

		if ($DetachAttach -eq $true) {
			Write-Message -Level Verbose -Message "Checking access to remote directories"
			$remoteSourcePath = Join-AdminUNC $sourceNetBios (Get-SqlDefaultPaths -SqlInstance $sourceServer -filetype data)

			if ((Test-Path $remoteSourcePath) -ne $true -and $DetachAttach) {
				Write-Message -Level Warning -Message "Can't access remote Sql directories on $source which is required to perform detach/copy/attach."
				Write-Message -Level Warning -Message "You can manually try accessing $remoteSourcePath to diagnose any issues."
				Stop-Function -Message "Halting database migration."
				return
			}

			$remoteDestPath = Join-AdminUNC $destNetBios (Get-SqlDefaultPaths -SqlInstance $destServer -filetype data)
			If ((Test-Path $remoteDestPath) -ne $true -and $DetachAttach) {
				Write-Message -Level Warning -Message "Can't access remote Sql directories on $destination which is required to perform detach/copy/attach."
				Write-Message -Level Warning -Message "You can manually try accessing $remoteDestPath to diagnose any issues."
				Stop-Function -Message "Halting database migration."
				return
			}
		}

		if (($Database -or $ExcludeDatabase -or $IncludeSupportDbs) -and (!$DetachAttach -and !$BackupRestore)) {
			Stop-Function -Message "You did not select a migration method. Please use -BackupRestore or -DetachAttach"
			return
		}

		if ((!$Database -and !$AllDatabases -and !$IncludeSupportDbs) -and ($DetachAttach -or $BackupRestore)) {
			Stop-Function -Message "You did not select any databases to migrate. Please use -AllDatabases or -Database or -IncludeSupportDbs"
			return
		}

		Write-Message -Level Verbose -Message "Building database list"
		$databaseList = New-Object System.Collections.ArrayList
		$SupportDBs = "ReportServer", "ReportServerTempDB", "distribution"
		foreach ($smoDb in $sourceServer.Databases) {
			$dbName = $smoDb.Name
			$dbOwner = $smoDb.Owner

			if ($smoDb.Id -le 4) { continue }
			if ($Database -and $Database -notcontains $dbName) { continue }
			if ($IncludeSupportDBs -eq $false -and $SupportDBs -contains $dbName) { continue }
			if ($IncludeSupportDBs -eq $true -and $SupportDBs -notcontains $dbName) {
				if ($AllDatabases -eq $false -and $Database.length -eq 0) { continue }
			}
			$null = $databaseList.Add($smoDb)
		}

		Write-Message -Level Verbose -Message "Performing count"
		$dbCount = $databaseList.Count

		Write-Message -Level Verbose -Message "Building file structure inventory for $dbCount databases"

		if ($sourceServer.VersionMajor -eq 8) {
			$sql = "select DB_NAME (dbid) as dbname, name, filename, CASE WHEN groupid = 0 THEN 'LOG' ELSE 'ROWS' END as filetype from sysaltfiles"
		}
		else {
			$sql = "SELECT db.Name AS dbname, type_desc AS FileType, mf.Name, Physical_Name AS filename FROM sys.master_files mf INNER JOIN  sys.databases db ON db.database_id = mf.database_id"
		}

		$dbFileTable = $sourceServer.Databases['master'].ExecuteWithResults($sql)

		if ($destServer.VersionMajor -eq 8) {
			$sql = "select DB_NAME (dbid) as dbname, name, filename, CASE WHEN groupid = 0 THEN 'LOG' ELSE 'ROWS' END as filetype from sysaltfiles"
		}
		else {
			$sql = "SELECT db.Name AS dbname, type_desc AS FileType, mf.Name, Physical_Name AS filename FROM sys.master_files mf INNER JOIN  sys.databases db ON db.database_id = mf.database_id"
		}

		$remoteDbFileTable = $destServer.Databases['master'].ExecuteWithResults($sql)

		$fileStructure = Get-SqlFileStructure -sourceserver $sourceServer -destserver $destServer -databaselist $databaseList -ReuseSourceFolderStructure $ReuseSourceFolderStructure

		$elapsed = [System.Diagnostics.Stopwatch]::StartNew()
		$started = Get-Date
		$script:TimeNow = (Get-Date -UFormat "%m%d%Y%H%M%S")

		$allDbElapsed = [System.Diagnostics.Stopwatch]::StartNew()

		if ($AllDatabases -or $ExcludeDatabase.length -gt 0 -or $IncludeSupportDbs -or $Database.length -gt 0) {
			foreach ($smoDb in $databaseList) {
				$dbElapsed = [System.Diagnostics.Stopwatch]::StartNew()
				$dbName = $smoDb.Name
				$dbOwner = $smoDb.Owner

				Write-Message -Level Verbose -Message "`n######### Database: $dbName #########"
				$dbStart = Get-Date

				if ($ExcludeDatabase -contains $dbName) {
					Write-Message -Level Verbose -Message "$dbName excluded. Skipping."
					continue
				}

				Write-Message -Level Verbose -Message "Checking for accessibility"
				if ($smoDb.IsAccessible -eq $false) {
					Write-Message -Level Warning -Message "Skipping $dbName. Database is inaccessible."
					continue
				}

				if ($fsWarning) {
					$fsRows = $dbFileTable.Tables[0].Select("dbname = '$dbName' and FileType = 'FileStream'")

					if ($fsRows.Count -gt 0) {
						Write-Message -Level Warning -Message "Skipping $dbName (contains FILESTREAM)"
						continue
					}
				}

				if ($ReuseSourceFolderStructure) {
					$fgRows = $dbFileTable.Tables[0].Select("dbname = '$dbName' and FileType = 'ROWS'")[0]
					$remotePath = Split-Path $fgRows
					$remotePath = Join-AdminUNC $destNetBios $remotePath

					if (!(Test-Path $remotePath)) {
						Stop-Function -Message "Cannot resolve $remotePath. `n`nYou have specified ReuseSourceFolderStructure and exact folder structure does not exist. Halting script."
						return
					}
				}

				Write-Message -Level Verbose -Message "Checking Availability Group status"
				if ($smoDb.AvailabilityGroupName.Length -gt 0 -and !$force -and $DetachAttach) {
					$agName = $smoDb.AvailabilityGroupName
					Write-Message -Level Warning -Message "Database is part of an Availability Group ($agName). Use -Force to drop from $agName and migrate. Alternatively, you can use the safer backup/restore method."
					continue
				}

				$dbStatus = $smoDb.Status.ToString()

				if ($dbStatus.StartsWith("Normal") -eq $false) {
					Write-Message -Level Warning -Message "$dbName is not in a Normal state. Skipping."
					continue
				}

				if ($smoDb.ReplicationOptions -ne "None" -and $DetachAttach -eq $true) {
					Write-Message -Level Warning -Message "$dbName is part of replication. Skipping."
					continue
				}

				if ($smoDb.IsMirroringEnabled -and !$force -and $DetachAttach) {
					Write-Message -Level Warning -Message "Database is being mirrored. Use -Force to break mirror and migrate. Alternatively, you can use the safer backup/restore method."
					continue
				}

				if (($destServer.Databases[$dbName] -ne $null) -and !$force -and !$WithReplace) {
					Write-Message -Level Warning -Message "Database exists at destination. Use -Force to drop and migrate. Aborting routine for this database."
					continue
				}
				elseif ($destServer.Databases[$dbName] -ne $null -and $force) {
					if ($Pscmdlet.ShouldProcess($destination, "DROP DATABASE $dbName")) {
						Write-Message -Level Verbose -Message "$dbName already exists. -Force was specified. Dropping $dbName on $destination."
						$dropResult = Remove-SqlDatabase $destServer $dbName

						if ($dropResult -eq $false) {
							Write-Message -Level Warning -Message "Database could not be dropped. Aborting routine for this database"
							continue
						}
					}
				}

				if ($force) {
					$WithReplace = $true
				}

				If ($Pscmdlet.ShouldProcess("console", "Showing start time")) {
					Write-Message -Level Verbose -Message "Started: $dbStart"
				}

				if ($sourceServer.VersionMajor -ge 9) {
					$sourceDbOwnerChaining = $sourceServer.Databases[$dbName].DatabaseOwnershipChaining
					$sourceDbTrustworthy = $sourceServer.Databases[$dbName].Trustworthy
					$sourceDbBrokerEnabled = $sourceServer.Databases[$dbName].BrokerEnabled

				}

				$sourceDbReadOnly = $sourceServer.Databases[$dbName].ReadOnly

				if ($SetSourceReadOnly) {
					If ($Pscmdlet.ShouldProcess($source, "Set $dbName to read-only")) {
						Write-Message -Level Verbose -Message "Setting database to read-only"
						$result = Update-SqldbReadOnly -SqlInstance $sourceServer -dbname $dbName -readonly $true

						if ($result -eq $false) {
							Write-Message -Level Warning -Message "Couldn't set database to read-only. Aborting routine for this database"
							continue
						}
					}
				}

				if ($BackupRestore) {
					If ($Pscmdlet.ShouldProcess($destination, "Backup $dbName from $source and restoring.")) {
						$fileName = "$dbName-$timeNow.bak"
						$backupFile = Join-Path $NetworkShare $fileName

						$backupTmpResult = Backup-DbaDatabase -SqlInstance $sourceServer -Database $dbName -backupDirectory (Split-Path -Path $backupFile -parent) -FileCount $numberfiles -NoCopyOnly:$NoCopyOnly
						$backupResult = $BackupTmpResult.BackupComplete
						if ($backupResult -eq $false) {
							$serviceAccount = $sourceServer.ServiceAccount
							Write-Message -Level Warning -Message "Backup Failed. Does Sql Server account $serviceAccount have access to $NetworkShare? Aborting routine for this database"
							continue
						}

						Write-Message -Level Verbose -Message "Resuse = $ReuseSourceFolderStructure"
						$restoreResultTmp = $backupTmpResult | Restore-DbaDatabase -SqlInstance $destServer -DatabaseName $dbName -ReuseSourceFolderStructure:$ReuseSourceFolderStructure -NoRecovery:$NoRecovery -TrustDbBackupHistory -WithReplace:$WithReplace
						$restoreResult = $restoreResultTmp.RestoreComplete

						if ($restoreResult -eq $true) {
							Write-Message -Level Verbose -Message "Successfully restored $dbName to $destination"
						}
						else {
							if ($ReuseSourceFolderStructure) {
								Write-Message -Level Warning -Message "Failed to restore $dbName to $destination. You specified -ReuseSourceFolderStructure. Does the exact same destination directory structure exist?"
								Write-Message -Level Warning -Message "Aborting routine for this database"
								continue
							}
							else {
								Write-Message -Level Warning -Message "Failed to restore $dbName to $destination. Aborting routine for this database."
								continue
							}
						}
						if ($NoBackupCleanUp -ne $true) {
							foreach ($backupFile in ($restoreResultTmp.BackupFile -split ',')) {
								try {
									if (Test-Path $backupFile -ErrorAction Stop) {
										Write-Message -Level Verbose -Message "Deleting $backupFile"
										Remove-Item $backupFile -ErrorAction Stop
									}
								}
								catch {
									try {
										Write-Message -Level Verbose -Message "Trying alternate SQL method to delete $backupFile"
										$sql = "EXEC master.sys.xp_delete_file 0, '$backupFile'"
										Write-Message -Level Debug -Message $sql
										$null = $server.ConnectionContext.ExecuteNonQuery($sql)
									}
									catch {
										Write-Message -Level Warning -Message "Cannot delete backup file $backupFile"

										# Set NoBackupCleanup so that there's a warning at the end
										$NoBackupCleanup = $true
									}
								}
							}
						}
					}

					$dbFinish = Get-Date

					if ($NoRecovery -eq $false) {
						Write-Message -Level Verbose -Message "Updating database owner"
						$result = Update-Sqldbowner -source $sourceServer -destination $destServer -dbname $dbName
					}
				}

				if ($DetachAttach) {
					$sourceFileStructure = New-Object System.Collections.Specialized.StringCollection
					foreach ($file in $fileStructure.Databases[$dbName].Source.Values) {
						$null = $sourceFileStructure.Add($file.Physical)
					}

					$dbOwner = $sourceServer.Databases[$dbName].Owner

					if ($dbOwner -eq $null) {
						$dbOwner = Get-SaLoginName -SqlInstance $destServer
					}

					if ($Pscmdlet.ShouldProcess($destination, "Detach $dbName from $source and attach, then update dbowner")) {
						$migrationResult = Start-SqlDetachAttach $sourceServer $destServer $fileStructure $dbName

						$dbFinish = Get-Date

						if ($reattach -eq $true) {
							$sourceServer.Databases.Refresh()
							$destServer.Databases.Refresh()
							$result = Mount-SqlDatabase $sourceServer $dbName $sourceFileStructure $dbOwner

							if ($result -eq $true) {
								$sourceServer.Databases[$dbName].DatabaseOwnershipChaining = $sourceDbOwnerChaining
								$sourceServer.Databases[$dbName].Trustworthy = $sourceDbTrustworthy
								$sourceServer.Databases[$dbName].BrokerEnabled = $sourceDbBrokerEnabled
								$sourceServer.Databases[$dbName].Alter()

								if ($SetSourceReadOnly) {
									$null = Update-SqldbReadOnly -SqlInstance $sourceServer -dbname $dbName -readonly $true
								}
								else {
									$null = Update-SqldbReadOnly -SqlInstance $sourceServer -dbname $dbName -readonly $sourceDbReadOnly
								}

								Write-Message -Level Verbose -Message "Successfully reattached $dbName to $source"
							}
							else {
								Write-Message -Level Warning -Message "Could not reattach $dbName to $source."
							}
						}


						if ($migrationResult -eq $true) {
							Write-Message -Level Verbose -Message "Successfully attached $dbName to $destination"
						}
						else {
							Write-Message -Level Warning -Message "Failed to attach $dbName to $destination. Aborting routine for this database."
							continue
						}
					}
				}
				$destServer.Databases.Refresh()

				# restore poentially lost settings
				if ($destServer.VersionMajor -ge 9 -and $NoRecovery -eq $false) {
					if ($sourceDbOwnerChaining -ne $destServer.Databases[$dbName].DatabaseOwnershipChaining) {
						if ($Pscmdlet.ShouldProcess($destination, "Updating DatabaseOwnershipChaining on $dbName")) {
							try {
								$destServer.Databases[$dbName].DatabaseOwnershipChaining = $sourceDbOwnerChaining
								$destServer.Databases[$dbName].Alter()
								Write-Message -Level Verbose -Message "Successfully updated DatabaseOwnershipChaining for $sourceDbOwnerChaining on $dbName on $destination"
							}
							catch {
								Write-Message -Level Warning -Message "Failed to update DatabaseOwnershipChaining for $sourceDbOwnerChaining on $dbName on $destination" -Silent:$silent
								Stop-Function -Message "Exception: $_" -Continue -Target $destination
							}
						}
					}

					if ($sourceDbTrustworthy -ne $destServer.Databases[$dbName].Trustworthy) {
						if ($Pscmdlet.ShouldProcess($destination, "Updating Trustworthy on $dbName")) {
							try {
								$destServer.Databases[$dbName].Trustworthy = $sourceDbTrustworthy
								$destServer.Databases[$dbName].Alter()
								Write-Message -Level Verbose -Message "Successfully updated Trustworthy to $sourceDbTrustworthy for $dbName on $destination"
							}
							catch {
								Write-Message -Level Warning -Message "Failed to update Trustworthy to $sourceDbTrustworthy for $dbName on $destination"
								Stop-Function -Message "Exception: $_" -Continue -Target $destination
							}
						}
					}

					if ($sourceDbBrokerEnabled -ne $destServer.Databases[$dbName].BrokerEnabled) {
						if ($Pscmdlet.ShouldProcess($destination, "Updating BrokerEnabled on $dbName")) {
							try {
								$destServer.Databases[$dbName].BrokerEnabled = $sourceDbBrokerEnabled
								$destServer.Databases[$dbName].Alter()
								Write-Message -Level Verbose -Message "Successfully updated BrokerEnabled to $sourceDbBrokerEnabled for $dbName on $destination"
							}
							catch {
								Write-Message -Level Warning -Message "Failed to update BrokerEnabled to $sourceDbBrokerEnabled for $dbName on $destination"
								Stop-Function -Message "Exception: $_" -Continue -Target $destination
							}
						}
					}
				}

				if ($sourceDbReadOnly -ne $destServer.Databases[$dbName].ReadOnly -and $NoRecovery -eq $false) {
					if ($Pscmdlet.ShouldProcess($destination, "Updating ReadOnly status on $dbName")) {
						$update = Update-SqldbReadOnly -SqlInstance $destServer -dbname $dbName -readonly $sourceDbReadOnly
						if ($update -eq $true) {
							Write-Message -Level Verbose -Message "Successfully updated readonly status on $dbName"
						}
						else {
							Write-Message -Level Warning -Message "Failed to update ReadOnly status on $dbName"
							Stop-Function -Message "Exception: $_" -Continue -Target $destination
						}
					}
				}

				if ($SetSourceOffline -and $sourceServer.databases[$dbName].status -notlike '*offline*') {
					if ($Pscmdlet.ShouldProcess($destination, "Setting $dbName offline on $source")) {
						Stop-DbaProcess -SqlInstance $sourceServer -Database $dbName
						Set-DbaDatabaseState -SqlInstance $sourceServer -Credential $SourceSqlCredential -database $dbName -Offline
					}
				}

				if ($Pscmdlet.ShouldProcess("console", "Showing elapsed time")) {
					$dbTotalTime = $dbFinish - $dbStart
					$dbTotalTime = ($dbTotalTime.ToString().Split(".")[0])

					Write-Message -Level Verbose -Message "Finished: $dbFinish"
					Write-Message -Level Verbose -Message "Elapsed time: $dbTotalTime"
				}
			} # end db by db processing
		}
	}
	end {
		if ($Pscmdlet.ShouldProcess("console", "Showing migration time elapsed")) {
			if ($null -ne $elapsed) {

				$totalTime = ($elapsed.Elapsed.toString().Split(".")[0])

				Write-Message -Level Verbose -Message "`nDatabase migration finished"
				Write-Message -Level Verbose -Message "Migration started: $started"
				Write-Message -Level Verbose -Message "Migration completed: $(Get-Date)"
				Write-Message -Level Verbose -Message "Total Elapsed time: $totalTime"

				if ($NetworkShare.length -gt 0 -and $NoBackupCleanup) {
					Write-Message -Level Warning -Message "Backups still exist at $NetworkShare."
				}
			}
			else {
				Write-Message -Level Verbose -Message "No work was done, as we stopped during setup phase"
			}
		}
		Test-DbaDeprecation -DeprecatedOn "1.0.0" -Silent:$false -Alias Copy-SqlDatabase
	}
}

