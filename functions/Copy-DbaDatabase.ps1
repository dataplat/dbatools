function Copy-DbaDatabase {
    <#
        .SYNOPSIS
            Migrates SQL Server databases from one SQL Server to another.

        .DESCRIPTION
            This script provides the ability to migrate databases using detach/copy/attach or backup/restore. This script works with named instances, clusters and SQL Server Express Edition.

            By default, databases will be migrated to the destination SQL Server's default data and log directories. You can override this by specifying -ReuseSourceFolderStructure. Filestreams and filegroups are also migrated. Safety is emphasized.

        .PARAMETER Source
            Source SQL Server. You must have sysadmin access and server version must be SQL Server version 2000 or higher.

        .PARAMETER SourceSqlCredential
            Allows you to login to servers using SQL Logins instead of Windows Authentication (AKA Integrated or Trusted). To use:

            $scred = Get-Credential, then pass $scred object to the -SourceSqlCredential parameter.

            Windows Authentication will be used if SourceSqlCredential is not specified. SQL Server does not accept Windows credentials being passed as credentials.

            To connect as a different Windows user, run PowerShell as that user.

        .PARAMETER Destination
            Destination SQL Server. You must have sysadmin access and the server must be SQL Server 2000 or higher.

        .PARAMETER DestinationSqlCredential
            Allows you to login to servers using SQL Logins instead of Windows Authentication (AKA Integrated or Trusted). To use:

            $dcred = Get-Credential, then pass this $dcred to the -DestinationSqlCredential parameter.

            Windows Authentication will be used if DestinationSqlCredential is not specified. SQL Server does not accept Windows credentials being passed as credentials.

            To connect as a different Windows user, run PowerShell as that user.

        .PARAMETER Database
            Migrates only specified databases. This list is auto-populated from the server for tab completion. Multiple databases may be specified as a collection.

        .PARAMETER ExcludeDatabase
            Excludes specified databases when performing -AllDatabases migrations. This list is auto-populated from the Source for tab completion.

        .PARAMETER AllDatabases
            If this switch is enabled, all user databases will be migrated. System and support databases will not be migrated. Requires -BackupRestore or -DetachAttach.

        .PARAMETER BackupRestore
            If this switch is enabled, the copy-only backup and restore method will be used to migrate the database(s). This method requires that you specify -NetworkShare in a valid UNC format (\\server\share).

            Backups will be immediately deleted after use unless -NoBackupCleanup is specified.

        .PARAMETER NetworkShare
            Specifies the network location for the backup files. The SQL Server service accounts must have read/write permission on this path.

        .PARAMETER WithReplace
            If this switch is enabled, the restore is executed with WITH REPLACE. This is useful if you want to stage some complex file paths.

        .PARAMETER NoRecovery
            If this switch is enabled, the restore is executed with WITH NORECOVERY. Ideal for staging.

        .PARAMETER NoBackupCleanup
            If this switch is enabled, backups generated by this cmdlet will not be deleted after they are restored. The default behavior is to delete these backups.

        .PARAMETER NumberFiles
            Number of files to split the backup. Default is 3.

        .PARAMETER DetachAttach
            If this switch is enabled, the detach/copy/attach method is used to perform database migrations. No files are deleted on Source. If Destination attachment fails, the Source database will be reattached. File copies are performed over administrative shares (\\server\x$\mssql) using BITS. If a database is being mirrored, the mirror will be broken prior to migration.

        .PARAMETER Reattach
            If this switch is enabled, all databases are reattached to Source after DetachAttach migration.

        .PARAMETER SetSourceReadOnly
            If this switch is enabled, all migrated databases are set to ReadOnly on Source prior to detach/attach & backup/restore.

            If -Reattach is used, databases are set to read-only after reattaching.

        .PARAMETER ReuseSourceFolderStructure
            If this switch is enabled, databases will be migrated to a data and log directory structure on Destination mirroring that used on Source. By default, the default data and log directories for Destination will be used when the databases are migrated.

            The structure on Source  will be kept exactly, so consider this if you're migrating between different versions and use part of Microsoft's default Sql structure (MSSql12.INSTANCE, etc)

            To reuse Destination folder structure, use the  -WithReplace switch.

        .PARAMETER IncludeSupportDbs
            If this switch is enabled, ReportServer, ReportServerTempDb, SSISDB, and distribution databases will be copied if they exist on Source. A logfile named $SOURCE-$DESTINATION-$date-Sqls.csv will be written to the current directory.

            Use of this switch requires -BackupRestore or -DetachAttach as well.

        .PARAMETER DatabaseCollection
            A collection of dbobjects from the pipeline.

        .PARAMETER NoCopyOnly
             If this switch is enabled, backups will be taken without COPY_ONLY. This will break the LSN backup chain, which will interfere with the restore chain of the database.

            By default this switch is disabled, so backups will be taken with COPY_ONLY. This will preserve the LSN backup chain.

            For more details please refer to this MSDN article - https://msdn.microsoft.com/en-us/library/ms191495.aspx

        .PARAMETER SetSourceOffline
            If this switch is enabled, the Source database will be set to Offline after being copied.

        .PARAMETER WhatIf
            If this switch is enabled, no actions are performed but informational messages will be displayed that explain what would happen if the command were to run.

        .PARAMETER Confirm
            If this switch is enabled, you will be prompted for confirmation before executing any operations that change state.

        .PARAMETER EnableException
            By default, when something goes wrong we try to catch it, interpret it and give you a friendly warning message.
            This avoids overwhelming you with "sea of red" exceptions, but is inconvenient because it basically disables advanced scripting.
            Using this switch turns this "nice by default" feature off and enables you to catch exceptions with your own try/catch.

        .PARAMETER Force
            If this switch is enabled, existing databases on Destination with matching names from Source will be dropped. If using -DetachReattach, mirrors will be broken and the database(s) dropped from Availability Groups.

        .NOTES
            Tags: Migration, DisasterRecovery, Backup, Restore
            Author: Chrissy LeMaire (@cl), netnerds.net
            Requires: sysadmin access on SQL Servers
            Limitations: Doesn't cover what it doesn't cover (replication, certificates, etc)
                        SQL Server 2000 databases cannot be directly migrated to SQL Server 2012 and above.
                        Logins within SQL Server 2012 and above logins cannot be migrated to SQL Server 2008 R2 and below.

            Website: https://dbatools.io
            Copyright: (C) Chrissy LeMaire, clemaire@gmail.com
            License: GNU GPL v3 https://opensource.org/licenses/GPL-3.0

        .LINK
            https://dbatools.io/Copy-DbaDatabase

        .EXAMPLE
            Copy-DbaDatabase -Source sqlserver2014a -Destination sqlserver2014b -Database TestDB -BackupRestore -NetworkShare \\fileshare\sql\migration

            Migrates a single user database TestDB using Backup and restore from instance sqlserver2014a to sqlserver2014b. Backup files are stored in \\fileshare\sql\migration.

        .EXAMPLE
            Copy-DbaDatabase -Source sqlserver2014a -Destination sqlcluster -DetachAttach -Reattach

            Databases will be migrated from sqlserver2014a to sqlcluster using the detach/copy files/attach method.The following will be performed: kick all users out of the database, detach all data/log files, move files across the network over an admin share (\\SqlSERVER\M$\MSSql...), attach file on destination server, reattach at source. If the database files (*.mdf, *.ndf, *.ldf) on *destination* exist and aren't in use, they will be overwritten.

        .EXAMPLE
            Copy-DbaDatabase -Source sqlserver2014a -Destination sqlcluster -ExcludeDatabase Northwind, pubs -IncludeSupportDbs -Force -BackupRestore -NetworkShare \\fileshare\sql\migration

            Migrates all user databases except for Northwind and pubs by using backup/restore (copy-only). Backup files are stored in \\fileshare\sql\migration. If the database exists on the destination, it will be dropped prior to attach.

            It also includes the support databases (ReportServer, ReportServerTempDb, distribution).
    #>
    [CmdletBinding(DefaultParameterSetName = "DbBackup", SupportsShouldProcess = $true)]
    Param (
        [parameter(Mandatory = $false)]
        [DbaInstanceParameter]
        $Source,

        [PSCredential]

        $SourceSqlCredential,

        [parameter(Mandatory = $true)]
        [DbaInstanceParameter]
        $Destination,

        [PSCredential]

        $DestinationSqlCredential,

        [Alias("Databases")]
        [object[]]
        $Database,

        [object[]]
        $ExcludeDatabase,

        [Alias("All")]
        [parameter(ParameterSetName = "DbBackup")]
        [parameter(ParameterSetName = "DbAttachDetach")]
        [switch]
        $AllDatabases,

        [parameter(Mandatory = $true, ParameterSetName = "DbBackup")]
        [switch]
        $BackupRestore,

        [parameter(Mandatory = $true, ParameterSetName = "DbBackup",
            HelpMessage = "Specify a valid network share in the format \\server\share that can be accessed by your account and the SQL Server service accounts for both Source and Destination.")]
        [string]
        $NetworkShare,

        [parameter(ParameterSetName = "DbBackup")]
        [switch]
        $WithReplace,

        [parameter(ParameterSetName = "DbBackup")]
        [switch]
        $NoRecovery,

        [parameter(ParameterSetName = "DbBackup")]
        [switch]
        $NoBackupCleanup,

        [parameter(ParameterSetName = "DbBackup")]
        [ValidateRange(1, 64)]
        [int]
        $NumberFiles = 3,

        [parameter(Mandatory = $true, ParameterSetName = "DbAttachDetach")]
        [switch]
        $DetachAttach,

        [parameter(ParameterSetName = "DbAttachDetach")]
        [switch]
        $Reattach,

        [parameter(ParameterSetName = "DbBackup")]
        [parameter(ParameterSetName = "DbAttachDetach")]
        [switch]
        $SetSourceReadOnly,

        [Alias("ReuseFolderStructure")]
        [parameter(ParameterSetName = "DbBackup")]
        [parameter(ParameterSetName = "DbAttachDetach")]
        [switch]
        $ReuseSourceFolderStructure,

        [parameter(ParameterSetName = "DbBackup")]
        [parameter(ParameterSetName = "DbAttachDetach")]
        [switch]
        $IncludeSupportDbs,

        [parameter(ValueFromPipeline = $True)]
        [object]
        $DatabaseCollection,

        [switch]
        $NoCopyOnly,

        [switch]
        $SetSourceOffline,

        [switch]
        $Force,

        [switch]
        [Alias('Silent')]$EnableException
    )
    begin {
        Test-DbaDeprecation -DeprecatedOn "1.0.0" -EnableException:$false -Alias Copy-SqlDatabase

        $CopyOnly = -not $NoCopyOnly
        function Join-AdminUnc {
            <#
        .SYNOPSIS
        Internal function. Parses a path to make it an admin UNC.
        #>
            [CmdletBinding()]
            param (
                [Parameter(Mandatory = $true)]
                [ValidateNotNullOrEmpty()]
                [string]
                $servername,

                [Parameter(Mandatory = $true)]
                [ValidateNotNullOrEmpty()]
                [string]
                $filepath

            )

            if ($script:sameserver) { return $filepath }
            if (!$filepath) { return }
            if ($filepath.StartsWith("\\")) { return $filepath }

            $servername = $servername.Split("\")[0]

            if ($filepath.length -gt 0 -and $filepath -ne [System.DbNull]::Value) {
                $newpath = Join-Path "\\$servername\" $filepath.replace(':', '$')
                return $newpath
            }
            else { return }
        }

        # Global Database Function
        function Get-SqlFileStructure {
            $dbcollection = @{ };
            $databaseProgressbar = 0

            foreach ($db in $databaseList) {
                Write-Progress -Id 1 -Activity "Processing database file structure" -PercentComplete ($databaseProgressbar / $dbCount * 100) -Status "Processing $databaseProgressbar of $dbCount."
                $dbName = $db.Name
                Write-Message -Level Verbose -Message $dbName

                $databaseProgressbar++
                $dbStatus = $db.status.toString()
                if ($dbStatus.StartsWith("Normal") -eq $false) { continue }
                $destinationfiles = @{ }; $sourcefiles = @{ }

                $where = "Filetype <> 'LOG' and Filetype <> 'FULLTEXT'"

                $datarows = $dbFileTable.Tables.Select("dbname = '$dbName' and $where")

                # Data Files
                foreach ($file in $datarows) {
                    # Destination File Structure
                    $d = @{ }
                    if ($ReuseSourceFolderStructure) {
                        $d.physical = $file.filename
                    }
                    elseif ($WithReplace) {
                        $name = $file.Name
                        $destfile = $remoteDbFileTable.Tables[0].Select("dbname = '$dbName' and name = '$name'")
                        $d.physical = $destfile.filename

                        if ($null -eq $d.physical) {
                            $directory = Get-SqlDefaultPaths $destServer data
                            $fileName = Split-Path $file.filename -Leaf
                            $d.physical = "$directory\$fileName"
                        }
                    }
                    else {
                        $directory = Get-SqlDefaultPaths $destServer data
                        $fileName = Split-Path $file.filename -Leaf
                        $d.physical = "$directory\$fileName"
                    }
                    $d.logical = $file.Name

                    $d.remotefilename = Join-AdminUNC $destNetBios $d.physical
                    $destinationfiles.add($file.Name, $d)

                    # Source File Structure
                    $s = @{ }
                    $s.logical = $file.Name
                    $s.physical = $file.filename
                    $s.remotefilename = Join-AdminUNC $sourceNetBios $s.physical
                    $sourcefiles.add($file.Name, $s)
                }

                # Add support for Full Text Catalogs in SQL Server 2005 and below
                if ($sourceServer.VersionMajor -lt 10) {
                    try {
                        $fttable = $null = $sourceServer.Databases[$dbName].ExecuteWithResults('sp_help_fulltext_catalogs')
                        $allrows = $fttable.Tables[0].rows
                    }
                    catch {
                        # Nothing, it's just not enabled
                    }

                    foreach ($ftc in $allrows) {
                        # Destination File Structure
                        $d = @{ }
                        $pre = "sysft_"
                        $name = $ftc.Name
                        $physical = $ftc.Path # RootPath
                        $logical = "$pre$name"
                        if ($ReuseSourceFolderStructure) {
                            $d.physical = $physical
                        }
                        else {
                            $directory = Get-SqlDefaultPaths $destServer data
                            if ($destServer.VersionMajor -lt 10) { $directory = "$directory\FTDATA" }
                            $fileName = Split-Path($physical) -leaf
                            $d.physical = "$directory\$fileName"
                        }
                        $d.logical = $logical
                        $d.remotefilename = Join-AdminUNC $destNetBios $d.physical
                        $destinationfiles.add($logical, $d)

                        # Source File Structure
                        $s = @{ }
                        $pre = "sysft_"
                        $name = $ftc.Name
                        $physical = $ftc.Path # RootPath
                        $logical = "$pre$name"

                        $s.logical = $logical
                        $s.physical = $physical
                        $s.remotefilename = Join-AdminUNC $sourceNetBios $s.physical
                        $sourcefiles.add($logical, $s)
                    }
                }

                $where = "Filetype = 'LOG'"
                $datarows = $dbFileTable.Tables[0].Select("dbname = '$dbName' and $where")

                # Log Files
                foreach ($file in $datarows) {
                    $d = @{ }
                    if ($ReuseSourceFolderStructure) {
                        $d.physical = $file.filename
                    }
                    elseif ($WithReplace) {
                        $name = $file.Name
                        $destfile = $remoteDbFileTable.Tables[0].Select("dbname = '$dbName' and name = '$name'")
                        $d.physical = $destfile.filename

                        if ($null -eq $d.physical) {
                            $directory = Get-SqlDefaultPaths $destServer data
                            $fileName = Split-Path $file.filename -Leaf
                            $d.physical = "$directory\$fileName"
                        }
                    }
                    else {
                        $directory = Get-SqlDefaultPaths $destServer log
                        $fileName = Split-Path $file.filename -Leaf
                        $d.physical = "$directory\$fileName"
                    }
                    $d.logical = $file.Name
                    $d.remotefilename = Join-AdminUNC $destNetBios $d.physical
                    $destinationfiles.add($file.Name, $d)

                    $s = @{ }
                    $s.logical = $file.Name
                    $s.physical = $file.filename
                    $s.remotefilename = Join-AdminUNC $sourceNetBios $s.physical
                    $sourcefiles.add($file.Name, $s)
                }

                $location = @{ }
                $location.add("Destination", $destinationfiles)
                $location.add("Source", $sourcefiles)
                $dbcollection.Add($($db.Name), $location)
            }

            $fileStructure = [pscustomobject]@{ "databases" = $dbcollection }
            Write-Progress -id 1 -Activity "Processing database file structure" -Status "Completed" -Completed
            return $fileStructure
        }

        # Detach Attach
        function Dismount-SqlDatabase {
            [CmdletBinding()]
            param (
                [object]
                $server,

                [string]
                $dbName
            )

            $currentdb = $server.databases[$dbName]
            if ($currentdb.IsMirroringEnabled) {
                try {
                    Write-Message -Level Verbose -Message "Breaking mirror for $dbName"
                    $currentdb.ChangeMirroringState([Microsoft.SqlServer.Management.Smo.MirroringOption]::Off)
                    $currentdb.Alter()
                    $currentdb.Refresh()
                    Write-Message -Level Verbose -Message "Could not break mirror for $dbName. Skipping."
                }
                catch {
                    Stop-Function -Message "Issue breaking mirror." -Target $dbName -ErrorRecord $_
                    return $false
                }
            }

            if ($currentdb.AvailabilityGroupName.Length -gt 0) {
                $agName = $currentdb.AvailabilityGroupName
                Write-Message -Level Verbose -Message "Attempting remove from Availability Group $agName."
                try {
                    $server.AvailabilityGroups[$currentdb.AvailabilityGroupName].AvailabilityDatabases[$dbName].Drop()
                    Write-Message -Level Verbose -Message "Successfully removed $dbName from  detach from $agName on $($server.Name)."
                }
                catch {
                    Stop-Function -Message "Could not remove $dbName from $agName on $($server.Name)." -Target $dbName -ErrorRecord $_
                    return $false
                }
            }

            Write-Message -Level Verbose -Message "Attempting detach from $dbName from $source."

            ####### Using Sql to detach does not modify the $currentdb collection #######

            $server.KillAllProcesses($dbName)

            try {
                $sql = "ALTER DATABASE [$dbName] SET SINGLE_USER WITH ROLLBACK IMMEDIATE"
                Write-Message -Level Verbose -Message $sql
                $null = $server.Query($sql)
                Write-Message -Level Verbose -Message "Successfully set $dbName to single-user from $source."
            }
            catch {
                Stop-Function -Message "Issue setting database to single-user." -Target $dbName -ErrorRecord $_
            }

            try {
                $sql = "EXEC master.dbo.sp_detach_db N'$dbName'"
                Write-Message -Level Verbose -Message $sql
                $null = $server.Query($sql)
                Write-Message -Level Verbose -Message "Successfully detached $dbName from $source."
                return $true
            }
            catch {
                Stop-Function -Message "Issue detaching database." -Target $dbName -ErrorRecord $_
                return $false
            }
        }

        function Mount-SqlDatabase {
            [CmdletBinding()]
            param (
                [object]
                $server,

                [string]
                $dbName,

                [object]
                $fileStructure,

                [string]
                $dbOwner
            )

            if ($server.Logins.Item($dbOwner) -eq $null) {
                try {
                    $dbOwner = ($destServer.logins | Where-Object { $_.id -eq 1 }).Name
                }
                catch {
                    $dbOwner = "sa"
                }
            }
            try {
                $null = $server.AttachDatabase($dbName, $fileStructure, $dbOwner, [Microsoft.SqlServer.Management.Smo.AttachOptions]::None)
                return $true
            }
            catch {
                Stop-Function -Message "Issue mounting database." -ErrorRecord $_
                return $false
            }
        }

        function Start-SqlFileTransfer {
            <#

            SYNOPSIS
            Internal function. Uses BITS to transfer detached files (.mdf, .ndf, .ldf, and filegroups) to
            another server over admin UNC paths. Locations of data files are kept in the
            custom object generated by Get-SqlFileStructure

            #>
            param (
                [object]
                $fileStructure,

                [string]
                $dbName
            )

            $copydb = $fileStructure.databases[$dbName]
            $dbsource = $copydb.source
            $dbdestination = $copydb.destination

            foreach ($file in $dbsource.keys) {
                $remotefilename = $dbdestination[$file].remotefilename
                $from = $dbsource[$file].remotefilename
                try {
                    if (Test-Path $from -pathtype container) {
                        $null = New-Item -ItemType Directory -Path $remotefilename -Force
                        Start-BitsTransfer -Source "$from\*.*" -Destination $remotefilename

                        $directories = (Get-ChildItem -recurse $from | Where-Object { $_.PsIsContainer }).FullName
                        foreach ($directory in $directories) {
                            $newdirectory = $directory.replace($from, $remotefilename)
                            $null = New-Item -ItemType Directory -Path $newdirectory -Force
                            Start-BitsTransfer -Source "$directory\*.*" -Destination $newdirectory
                        }
                    }
                    else {
                        Write-Message -Level Verbose -Message "Copying $from for $dbName."
                        Start-BitsTransfer -Source $from -Destination $remotefilename
                    }
                    $fn = Split-Path $($dbdestination[$file].physical) -leaf
                }
                catch {
                    try {
                        # Sometimes BITS trips out temporarily on cloned drives.
                        Start-BitsTransfer -Source $from -Destination $remotefilename
                    }
                    catch {
                        Write-Message -Level Verbose -Message "Start-BitsTransfer did not succeed. Now attempting with Copy-Item - no progress bar will be shown."
                        try {
                            Copy-Item -Path $from -Destination $remotefilename -ErrorAction Stop
                        }
                        catch {
                            Write-Message -Level Verbose -Message "Access denied. This can happen for a number of reasons including issues with cloned disks."
                            Stop-Function -Message "Alternatively, you may need to run PowerShell as Administrator, especially when running on localhost." -Target $from -ErrorRecord $_
                            return
                        }
                    }
                }
            }
            return $true
        }

        function Start-SqlDetachAttach {
            <#

            .SYNOPSIS
            Internal function. Performs checks, then executes Dismount-SqlDatabase on a database, copies its files to the new server,    then performs Mount-SqlDatabase. $sourceServer and $destServer are SMO server objects.

            $fileStructure is a custom object generated by Get-SqlFileStructure

            #>
            [CmdletBinding()]
            param (
                [object]
                $sourceServer,

                [object]
                $destServer,

                [object]
                $fileStructure,

                [string]
                $dbName
            )

            $destfilestructure = New-Object System.Collections.Specialized.StringCollection
            $sourceFileStructure = New-Object System.Collections.Specialized.StringCollection
            $dbOwner = $sourceServer.databases[$dbName].owner

            if ($dbOwner -eq $null) {
                try {
                    $dbOwner = ($destServer.logins | Where-Object { $_.id -eq 1 }).Name
                }
                catch {
                    $dbOwner = "sa"
                }
            }

            foreach ($file in $fileStructure.databases[$dbName].destination.values) { $null = $destfilestructure.add($file.physical) }
            foreach ($file in $fileStructure.databases[$dbName].source.values) { $null = $sourceFileStructure.add($file.physical) }

            $detachresult = Dismount-SqlDatabase $sourceServer $dbName

            if ($detachresult) {
                $transfer = Start-SqlFileTransfer $fileStructure $dbName
                if ($transfer -eq $false) { Write-Warning "Could not copy files."; return "Could not copy files." }
                $attachresult = Mount-SqlDatabase $destServer $dbName $destfilestructure $dbOwner

                if ($attachresult -eq $true) {
                    # add to added dbs because ATTACH was successful
                    Write-Message -Level Verbose -Message "Successfully attached $dbName to $destination."
                    return $true
                }
                else {
                    # add to failed because ATTACH was unsuccessful
                    Write-Message -Level Verbose -Message "Could not attach $dbName."
                    return "Could not attach database."
                }
            }
            else {
                # add to failed because DETACH was unsuccessful
                Write-Message -Level Verbose -Message "Could not detach $dbName."
                return "Could not detach database."
            }
        }

    }
    process {
        if (Test-FunctionInterrupt) { return }

        if (($AllDatabases -or $IncludeSupportDbs -or $Database) -and !$DetachAttach -and !$BackupRestore) {
            Stop-Function -Message "You must specify -DetachAttach or -BackupRestore when migrating databases."
            return
        }

        if ($DatabaseCollection.Length -gt 0) {
            $Source = $DatabaseCollection[0].Parent.Name
            $Database = $DatabaseCollection.Name
        }

        if ($Database -contains "master" -or $Database -contains "msdb" -or $Database -contains "tempdb") {
            Stop-Function -Message "Migrating system databases is not currently supported."
            return
        }

        if (!$AllDatabases -and !$IncludeSupportDbs -and !$Database) {
            Stop-Function -Message "You must specify a -AllDatabases or -Database to continue."
            return
        }

        Write-Message -Level Verbose -Message "Attempting to connect to SQL Servers."
        $sourceServer = Connect-SqlInstance -SqlInstance $Source -SqlCredential $SourceSqlCredential
        $destServer = Connect-SqlInstance -SqlInstance $Destination -SqlCredential $DestinationSqlCredential

        if ($sourceServer.ComputerNamePhysicalNetBIOS -eq $destServer.ComputerNamePhysicalNetBIOS) {
            $script:sameserver = $true
        }
        else {
            $script:sameserver = $false
        }

        if ($script:sameserver -and $DetachAttach) {
            if (-not (Test-ElevationRequirement -ComputerName $sourceServer)) { return }
        }

        $destVersionLower = $destServer.VersionMajor -lt $sourceServer.VersionMajor
        $destVersionMinorLow = ($destServer.VersionMajor -eq 10 -and $sourceServer.VersionMajor -eq 10) -and ($destServer.VersionMinor -lt $sourceServer.VersionMinor)

        if ($destVersionLower -or $destVersionMinorLow) {
            Stop-Function -Message "Error: copy database cannot be made from newer $($sourceServer.VersionString) to older $($destServer.VersionString) SQL Server version."
            return
        }

        if ($DetachAttach) {
            if ($sourceServer.NetName -eq $env:COMPUTERNAME -or $destServer.NetName -eq $env:COMPUTERNAME) {
                if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
                    Write-Message -Level Verbose -Message "When running DetachAttach locally on the console, it's possible you'll need to Run As Administrator. Trying anyway."
                }
            }
        }

        $source = $sourceServer.DomainInstanceName
        $destination = $destServer.DomainInstanceName

        if ($NetworkShare.Length -gt 0) {
            if ($(Test-DbaSqlPath -SqlInstance $sourceServer -Path $NetworkShare) -eq $false) {
                Write-Message -Level Verbose -Message "$Source may not be able to access $NetworkShare. Trying anyway."
            }

            if ($(Test-DbaSqlPath -SqlInstance $destServer -Path $NetworkShare) -eq $false) {
                Write-Message -Level Verbose -Message "$Destination may not be able to access $NetworkShare. Trying anyway."
            }

            if ($NetworkShare.StartsWith('\\')) {
                try {
                    $shareServer = ($NetworkShare -split "\\")[2]
                    $hostEntry = ([Net.Dns]::GetHostEntry($shareServer)).HostName -split "\."

                    if ($shareServer -ne $hostEntry[0]) {
                        Write-Message -Level Verbose -Message "Using CNAME records for the network share may present an issue if an SPN has not been created. Trying anyway. If it doesn't work, use a different (A record) hostname."
                    }
                }
                catch {
                    Stop-Function -Message "Error validating unc path: $_"
                    return
                }
            }
        }

        Write-Message -Level Verbose -Message "Resolving NetBIOS names."
        $sourceNetBios = Resolve-NetBiosName $sourceServer
        $destNetBios = Resolve-NetBiosName $destServer

        Write-Message -Level Verbose -Message "Performing SMO version check."
        Invoke-SmoCheck -SqlInstance $sourceServer
        Invoke-SmoCheck -SqlInstance $destServer

        Write-Message -Level Verbose -Message "Checking to ensure the source isn't the same as the destination."
        if ($source -eq $destination) {
            Stop-Function -Message "Source and Destination SQL Servers instances are the same. Quitting."
            return
        }

        if ($NetworkShare.Length -gt 0) {
            Write-Message -Level Verbose -Message "Checking to ensure network path is valid."
            if (!($NetworkShare.StartsWith("\\")) -and !$script:sameserver) {
                Stop-Function -Message "Network share must be a valid UNC path (\\server\share)."
                return
            }

            if (!$script:sameserver) {
                try {
                    if ((Test-Path $NetworkShare -ErrorAction Stop)) {
                        Write-Message -Level Verbose -Message "$NetworkShare share can be accessed."
                    }
                }
                catch {
                    Write-Message -Level Verbose -Message "$NetworkShare share cannot be accessed. Still trying anyway, in case the SQL Server service accounts have access."
                }
            }
        }

        Write-Message -Level Verbose -Message "Checking to ensure server is not SQL Server 7 or below."
        if ($sourceServer.VersionMajor -lt 8 -and $destServer.VersionMajor -lt 8) {
            Stop-Function -Message "This script can only be run on SQL Server 2000 and above. Quitting."
            return
        }

        Write-Message -Level Verbose -Message "Checking to ensure detach/attach is not attempted on SQL Server 2000."
        if ($destServer.VersionMajor -lt 9 -and $DetachAttach) {
            Stop-Function -Message "Detach/Attach not supported when destination SQL Server is version 2000. Quitting." -Target $destServer
            return
        }

        Write-Message -Level Verbose -Message "Checking to ensure SQL Server 2000 migration isn't directly attempted to SQL Server 2012."
        if ($sourceServer.VersionMajor -lt 9 -and $destServer.VersionMajor -gt 10) {
            Stop-Function -Message "SQL Server 2000 databases cannot be migrated to SQL Server versions 2012 and above. Quitting." -Target $destServer
            return
        }

        Write-Message -Level Verbose -Message "Warning if migration from 2005 to 2012 and above and attach/detach is used."
        if ($sourceServer.VersionMajor -eq 9 -and $destServer.VersionMajor -gt 9 -and !$BackupRestore -and !$Force -and $DetachAttach) {
            Stop-Function -Message "Backup and restore is the safest method for migrating from SQL Server 2005 to other SQL Server versions. Please use the -BackupRestore switch or override this requirement by specifying -Force."
            return
        }

        if ($sourceServer.Collation -ne $destServer.Collation) {
            Write-Message -Level Verbose -Message "Warning on different collation."
            Write-Message -Level Verbose -Message "Collation on $Source, $($sourceServer.Collation) differs from the $Destination, $($destServer.Collation)."
        }

        Write-Message -Level Verbose -Message "Ensuring user databases exist (counting databases)."
        $dbTotal = $sourceServer.Databases.Count

        if ($dbTotal -le 4) {
            Stop-Function -Message "No user databases to migrate. Quitting."
        }

        Write-Message -Level Verbose -Message "Ensuring destination server version is equal to or greater than source."
        if ($sourceServer.VersionMajor -ge $destServer.VersionMajor) {
            if ($sourceServer.VersionMinor -gt $destServer.VersionMinor) {
                Stop-Function -Message "Source SQL Server version build must be <= destination SQL Server for database migration."
            }
        }

        # SMO's filestreamlevel is sometimes null
        $sql = "select coalesce(SERVERPROPERTY('FilestreamConfiguredLevel'),0) as fs"
        $sourceFilestream = $sourceServer.ConnectionContext.ExecuteScalar($sql)
        $destFilestream = $destServer.ConnectionContext.ExecuteScalar($sql)
        if ($sourceFilestream -gt 0 -and $destFilestream -eq 0) {
            $fsWarning = $true
        }

        Write-Message -Level Verbose -Message "Writing warning about filestream being enabled."
        if ($fsWarning) {
            Write-Message -Level Verbose -Message "FILESTREAM enabled on $source but not $destination. Databases that use FILESTREAM will be skipped."
        }

        if ($DetachAttach -eq $true) {
            Write-Message -Level Verbose -Message "Checking access to remote directories."
            $remoteSourcePath = Join-AdminUNC $sourceNetBios (Get-SqlDefaultPaths -SqlInstance $sourceServer -filetype data)

            if ((Test-Path $remoteSourcePath) -ne $true -and $DetachAttach) {
                Write-Message -Level Verbose -Message "Can't access remote Sql directories on $source which is required to perform detach/copy/attach."
                Write-Message -Level Verbose -Message "You can manually try accessing $remoteSourcePath to diagnose any issues."
                Stop-Function -Message "Halting database migration."
                return
            }

            $remoteDestPath = Join-AdminUNC $destNetBios (Get-SqlDefaultPaths -SqlInstance $destServer -filetype data)
            If ((Test-Path $remoteDestPath) -ne $true -and $DetachAttach) {
                Write-Message -Level Verbose -Message "Can't access remote Sql directories on $destination which is required to perform detach/copy/attach."
                Write-Message -Level Verbose -Message "You can manually try accessing $remoteDestPath to diagnose any issues."
                Stop-Function -Message "Halting database migration."
                return
            }
        }

        if (($Database -or $ExcludeDatabase -or $IncludeSupportDbs) -and (!$DetachAttach -and !$BackupRestore)) {
            Stop-Function -Message "You did not select a migration method. Please use -BackupRestore or -DetachAttach."
            return
        }

        if ((!$Database -and !$AllDatabases -and !$IncludeSupportDbs) -and ($DetachAttach -or $BackupRestore)) {
            Stop-Function -Message "You did not select any databases to migrate. Please use -AllDatabases or -Database or -IncludeSupportDbs."
            return
        }

        Write-Message -Level Verbose -Message "Building database list."
        $databaseList = New-Object System.Collections.ArrayList
        $SupportDBs = "ReportServer", "ReportServerTempDB", "distribution"
        foreach ($currentdb in ($sourceServer.Databases | Where-Object IsAccessible)) {
            $dbName = $currentdb.Name
            $dbOwner = $currentdb.Owner

            if ($currentdb.Id -le 4) { continue }
            if ($Database -and $Database -notcontains $dbName) { continue }
            if ($IncludeSupportDBs -eq $false -and $SupportDBs -contains $dbName) { continue }
            if ($IncludeSupportDBs -eq $true -and $SupportDBs -notcontains $dbName) {
                if ($AllDatabases -eq $false -and $Database.length -eq 0) { continue }
            }
            $null = $databaseList.Add($currentdb)
        }

        Write-Message -Level Verbose -Message "Performing count."
        $dbCount = $databaseList.Count

        Write-Message -Level Verbose -Message "Building file structure inventory for $dbCount databases."

        if ($sourceServer.VersionMajor -eq 8) {
            $sql = "select DB_NAME (dbid) as dbname, name, filename, CASE WHEN groupid = 0 THEN 'LOG' ELSE 'ROWS' END as filetype from sysaltfiles"
        }
        else {
            $sql = "SELECT db.Name AS dbname, type_desc AS FileType, mf.Name, Physical_Name AS filename FROM sys.master_files mf INNER JOIN  sys.databases db ON db.database_id = mf.database_id"
        }

        $dbFileTable = $sourceServer.Databases['master'].ExecuteWithResults($sql)

        if ($destServer.VersionMajor -eq 8) {
            $sql = "select DB_NAME (dbid) as dbname, name, filename, CASE WHEN groupid = 0 THEN 'LOG' ELSE 'ROWS' END as filetype from sysaltfiles"
        }
        else {
            $sql = "SELECT db.Name AS dbname, type_desc AS FileType, mf.Name, Physical_Name AS filename FROM sys.master_files mf INNER JOIN  sys.databases db ON db.database_id = mf.database_id"
        }

        $remoteDbFileTable = $destServer.Databases['master'].ExecuteWithResults($sql)

        $fileStructure = Get-SqlFileStructure -sourceserver $sourceServer -destserver $destServer -databaselist $databaseList -ReuseSourceFolderStructure $ReuseSourceFolderStructure

        $elapsed = [System.Diagnostics.Stopwatch]::StartNew()
        $started = Get-Date
        $script:TimeNow = (Get-Date -UFormat "%m%d%Y%H%M%S")

        $allDbElapsed = [System.Diagnostics.Stopwatch]::StartNew()

        if ($AllDatabases -or $ExcludeDatabase.length -gt 0 -or $IncludeSupportDbs -or $Database.length -gt 0) {
            foreach ($currentdb in $databaseList) {
                $dbElapsed = [System.Diagnostics.Stopwatch]::StartNew()
                $dbName = $currentdb.Name
                $dbOwner = $currentdb.Owner

                $copyDatabaseStatus = [pscustomobject]@{
                    SourceServer        = $sourceServer.Name
                    DestinationServer   = $destServer.Name
                    Name                = $dbName
                    DestinationDatabase = $dbname
                    Type                = "Database"
                    Status              = $null
                    Notes               = $null
                    DateTime            = [DbaDateTime](Get-Date)
                }

                Write-Message -Level Verbose -Message "`n######### Database: $dbName #########"
                $dbStart = Get-Date

                if ($ExcludeDatabase -contains $dbName) {
                    Write-Message -Level Verbose -Message "$dbName excluded. Skipping."
                    continue
                }

                Write-Message -Level Verbose -Message "Checking for accessibility."
                if ($currentdb.IsAccessible -eq $false) {
                    Write-Message -Level Verbose -Message "Skipping $dbName. Database is inaccessible."

                    $copyDatabaseStatus.Status = "Skipped"
                    $copyDatabaseStatus.Notes = "Database is not accessible"
                    $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                    continue
                }

                if ($fsWarning) {
                    $fsRows = $dbFileTable.Tables[0].Select("dbname = '$dbName' and FileType = 'FileStream'")

                    if ($fsRows.Count -gt 0) {
                        Write-Message -Level Verbose -Message "Skipping $dbName (contains FILESTREAM)."
                        $copyDatabaseStatus.Status = "Skipped"
                        $copyDatabaseStatus.Notes = "Contains FILESTREAM"
                        $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                        continue
                    }
                }

                if ($ReuseSourceFolderStructure) {
                    $fgRows = $dbFileTable.Tables[0].Select("dbname = '$dbName' and FileType = 'ROWS'")[0]
                    $remotePath = Split-Path $fgRows.Filename

                    if (!(Test-DbaSqlPath -SqlInstance $destServer -Path $remotePath)) {
                        # Stop-Function -Message "Cannot resolve $remotePath on $source. `n`nYou have specified ReuseSourceFolderStructure and exact folder structure does not exist. Halting script."
                        $copyDatabaseStatus.Status = "Failed"
                        $copyDatabaseStatus.Notes = "$remotePath does not exist on $destination and ReuseSourceFolderStructure was specified" #"Can't resolve $remotePath"
                        $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                        return
                    }
                }

                Write-Message -Level Verbose -Message "Checking Availability Group status."
                if ($currentdb.AvailabilityGroupName.Length -gt 0 -and !$force -and $DetachAttach) {
                    $agName = $currentdb.AvailabilityGroupName
                    Write-Message -Level Verbose -Message "Database is part of an Availability Group ($agName). Use -Force to drop from $agName and migrate. Alternatively, you can use the safer backup/restore method."
                    continue
                }

                $dbStatus = $currentdb.Status.ToString()

                if ($dbStatus.StartsWith("Normal") -eq $false) {
                    Write-Message -Level Verbose -Message "$dbName is not in a Normal state. Skipping."

                    $copyDatabaseStatus.Status = "Skipped"
                    $copyDatabaseStatus.Notes = "Not in normal state"
                    $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                    continue
                }

                if ($currentdb.ReplicationOptions -ne "None" -and $DetachAttach -eq $true) {
                    Write-Message -Level Verbose -Message "$dbName is part of replication. Skipping."

                    $copyDatabaseStatus.Status = "Skipped"
                    $copyDatabaseStatus.Notes = "Part of replication"
                    $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                    continue
                }

                if ($currentdb.IsMirroringEnabled -and !$force -and $DetachAttach) {
                    Write-Message -Level Verbose -Message "Database is being mirrored. Use -Force to break mirror and migrate. Alternatively, you can use the safer backup/restore method."

                    $copyDatabaseStatus.Status = "Skipped"
                    $copyDatabaseStatus.Notes = "Database is mirrored"
                    $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                    continue
                }

                if (($destServer.Databases[$dbName] -ne $null) -and !$force -and !$WithReplace) {
                    Write-Message -Level Verbose -Message "Database exists at destination. Use -Force to drop and migrate. Aborting routine for this database."

                    $copyDatabaseStatus.Status = "Skipped"
                    $copyDatabaseStatus.Notes = "Already exists"
                    $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                    continue
                }
                elseif ($destServer.Databases[$dbName] -ne $null -and $force) {
                    if ($Pscmdlet.ShouldProcess($destination, "DROP DATABASE $dbName")) {
                        Write-Message -Level Verbose -Message "$dbName already exists. -Force was specified. Dropping $dbName on $destination."
                        $dropResult = Remove-SqlDatabase $destServer $dbName

                        if ($dropResult -eq $false) {
                            Write-Message -Level Verbose -Message "Database could not be dropped. Aborting routine for this database."

                            $copyDatabaseStatus.Status = "Failed"
                            $copyDatabaseStatus.Notes = "Could not drop database"
                            $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                            continue
                        }
                    }
                }

                if ($force) {
                    $WithReplace = $true
                }

                if ($Pscmdlet.ShouldProcess("console", "Showing start time")) {
                    Write-Message -Level Verbose -Message "Started: $dbStart."
                }

                if ($sourceServer.VersionMajor -ge 9) {
                    $sourceDbOwnerChaining = $sourceServer.Databases[$dbName].DatabaseOwnershipChaining
                    $sourceDbTrustworthy = $sourceServer.Databases[$dbName].Trustworthy
                    $sourceDbBrokerEnabled = $sourceServer.Databases[$dbName].BrokerEnabled
                }

                $sourceDbReadOnly = $sourceServer.Databases[$dbName].ReadOnly

                if ($SetSourceReadOnly) {
                    If ($Pscmdlet.ShouldProcess($source, "Set $dbName to read-only")) {
                        Write-Message -Level Verbose -Message "Setting database to read-only."
                        $result = Update-SqldbReadOnly -SqlInstance $sourceServer -dbname $dbName -readonly:$true

                        if ($result -eq $false) {
                            Write-Message -Level Verbose -Message "Couldn't set database to read-only. Aborting routine for this database."
                            continue
                        }
                    }
                }

                if ($BackupRestore) {
                    If ($Pscmdlet.ShouldProcess($destination, "Backup $dbName from $source and restoring.")) {
                        $copyDatabaseStatus.Type = "Database (BackupRestore)"

                        $fileName = "$dbName-$timeNow.bak"
                        $backupFile = Join-Path $NetworkShare $fileName
                        $backupTmpResult = Backup-DbaDatabase -SqlInstance $sourceServer -Database $dbName -backupDirectory (Split-Path -Path $backupFile -parent) -FileCount $numberfiles -CopyOnly:$CopyOnly
                        $backupResult = $BackupTmpResult.BackupComplete
                        if ($backupResult -eq $false) {
                            $serviceAccount = $sourceServer.ServiceAccount
                            Write-Message -Level Verbose -Message "Backup Failed. Does SQL Server account $serviceAccount have access to $($NetworkShare)? Aborting routine for this database."

                            $copyDatabaseStatus.Status = "Failed"
                            $copyDatabaseStatus.Notes = "Backup failed. Verify service account access to $NetworkShare."
                            $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                            continue
                        }

                        Write-Message -Level Verbose -Message "Resuse = $ReuseSourceFolderStructure."
                        $restoreResultTmp = $backupTmpResult | Restore-DbaDatabase -SqlInstance $destServer -DatabaseName $dbName -ReuseSourceFolderStructure:$ReuseSourceFolderStructure -NoRecovery:$NoRecovery -TrustDbBackupHistory -WithReplace:$WithReplace
                        $restoreResult = $restoreResultTmp.RestoreComplete

                        if ($restoreResult -eq $true) {
                            Write-Message -Level Verbose -Message "Successfully restored $dbName to $destination."
                            $copyDatabaseStatus.Status = "Successful"
                            $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                        }
                        else {
                            if ($ReuseSourceFolderStructure) {
                                Write-Message -Level Verbose -Message "Failed to restore $dbName to $destination. You specified -ReuseSourceFolderStructure. Does the exact same destination directory structure exist?"
                                Write-Message -Level Verbose -Message "Aborting routine for this database."

                                $copyDatabaseStatus.Status = "Failed"
                                $copyDatabaseStatus.Notes = "Failed to restore. ReuseSourceFolderStructure was specified, verify same directory structure exist on destination."
                                $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                                continue
                            }
                            else {
                                Write-Message -Level Verbose -Message "Failed to restore $dbName to $destination. Aborting routine for this database."

                                $copyDatabaseStatus.Status = "Failed"
                                $copyDatabaseStatus.Notes = "Failed to restore database"
                                $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                                continue
                            }
                        }
                        if ($NoBackupCleanUp -ne $true) {
                            foreach ($backupFile in ($restoreResultTmp.BackupFile -split ',')) {
                                try {
                                    if (Test-Path $backupFile -ErrorAction Stop) {
                                        Write-Message -Level Verbose -Message "Deleting $backupFile."
                                        Remove-Item $backupFile -ErrorAction Stop
                                    }
                                }
                                catch {
                                    try {
                                        Write-Message -Level Verbose -Message "Trying alternate SQL method to delete $backupFile."
                                        $sql = "EXEC master.sys.xp_delete_file 0, '$backupFile'"
                                        Write-Message -Level Debug -Message $sql
                                        $null = $sourceServer.Query($sql)
                                    }
                                    catch {
                                        Write-Message -Level Verbose -Message "Cannot delete backup file $backupFile."

                                        # Set NoBackupCleanup so that there's a warning at the end
                                        $NoBackupCleanup = $true
                                    }
                                }
                            }
                        }
                    }

                    $dbFinish = Get-Date
                    if ($NoRecovery -eq $false) {
                        # needed because the newly restored database doesn't show up
                        $destServer.Databases.Refresh()
                        $dbOwner = $sourceServer.Databases[$dbName].Owner
                        if ($null -eq $dbOwner -or $destServer.Logins.Name -notcontains $dbOwner) {
                            $dbOwner = Get-SaLoginName -SqlInstance $destServer
                        }
                        Write-Message -Level Verbose -Message "Updating database owner to $dbOwner."
                        $OwnerResult = Set-DbaDatabaseOwner -SqlInstance $destServer -Database $dbName -TargetLogin $dbOwner -EnableException
                        if ($OwnerResult.Length -eq 0) {
                            Write-Message -Level Verbose -Message "Failed to update database owner."
                        }
                    }
                }

                if ($DetachAttach) {
                    $copyDatabaseStatus.Type = "Database (DetachAttach)"

                    $sourceFileStructure = New-Object System.Collections.Specialized.StringCollection
                    foreach ($file in $fileStructure.Databases[$dbName].Source.Values) {
                        $null = $sourceFileStructure.Add($file.Physical)
                    }

                    $dbOwner = $sourceServer.Databases[$dbName].Owner

                    if ($null -eq $dbOwner -or $destServer.Logins.Name -notcontains $dbOwner) {
                        $dbOwner = Get-SaLoginName -SqlInstance $destServer
                    }

                    if ($Pscmdlet.ShouldProcess($destination, "Detach $dbName from $source and attach, then update dbowner")) {
                        $migrationResult = Start-SqlDetachAttach $sourceServer $destServer $fileStructure $dbName

                        $dbFinish = Get-Date

                        if ($reattach -eq $true) {
                            $sourceServer.Databases.Refresh()
                            $destServer.Databases.Refresh()
                            $result = Mount-SqlDatabase $sourceServer $dbName $sourceFileStructure $dbOwner

                            if ($result -eq $true) {
                                $sourceServer.Databases[$dbName].DatabaseOwnershipChaining = $sourceDbOwnerChaining
                                $sourceServer.Databases[$dbName].Trustworthy = $sourceDbTrustworthy
                                $sourceServer.Databases[$dbName].BrokerEnabled = $sourceDbBrokerEnabled
                                $sourceServer.Databases[$dbName].Alter()

                                if ($SetSourceReadOnly) {
                                    $null = Update-SqldbReadOnly -SqlInstance $sourceServer -dbname $dbName -readonly $true
                                }
                                else {
                                    $null = Update-SqldbReadOnly -SqlInstance $sourceServer -dbname $dbName -readonly $sourceDbReadOnly
                                }

                                Write-Message -Level Verbose -Message "Successfully reattached $dbName to $source."
                            }
                            else {
                                Write-Message -Level Verbose -Message "Could not reattach $dbName to $source."
                                $copyDatabaseStatus.Status = "Failed"
                                $copyDatabaseStatus.Notes = "Could not reattach database to $source"
                                $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                            }
                        }

                        if ($migrationResult -eq $true) {
                            Write-Message -Level Verbose -Message "Successfully attached $dbName to $destination."
                            $copyDatabaseStatus.Status = "Successful"
                            $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                        }
                        else {
                            Write-Message -Level Verbose -Message "Failed to attach $dbName to $destination. Aborting routine for this database."

                            $copyDatabaseStatus.Status = "Failed"
                            $copyDatabaseStatus.Notes = "Failed to attach database to destination"
                            $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject

                            continue
                        }
                    }
                }
                $destServer.Databases.Refresh()

                # restore potentially lost settings
                if ($destServer.VersionMajor -ge 9 -and $NoRecovery -eq $false) {
                    if ($sourceDbOwnerChaining -ne $destServer.Databases[$dbName].DatabaseOwnershipChaining) {
                        if ($Pscmdlet.ShouldProcess($destination, "Updating DatabaseOwnershipChaining on $dbName")) {
                            try {
                                $destServer.Databases[$dbName].DatabaseOwnershipChaining = $sourceDbOwnerChaining
                                $destServer.Databases[$dbName].Alter()
                                Write-Message -Level Verbose -Message "Successfully updated DatabaseOwnershipChaining for $sourceDbOwnerChaining on $dbName on $destination."
                            }
                            catch {
                                $copyDatabaseStatus.Status = "Successful - failed to apply DatabaseOwnershipChaining."
                                $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                                Stop-Function -Message "Failed to update DatabaseOwnershipChaining for $sourceDbOwnerChaining on $dbName on $destination." -Target $destination -ErrorRecord $_ -Continue
                            }
                        }
                    }

                    if ($sourceDbTrustworthy -ne $destServer.Databases[$dbName].Trustworthy) {
                        if ($Pscmdlet.ShouldProcess($destination, "Updating Trustworthy on $dbName")) {
                            try {
                                $destServer.Databases[$dbName].Trustworthy = $sourceDbTrustworthy
                                $destServer.Databases[$dbName].Alter()
                                Write-Message -Level Verbose -Message "Successfully updated Trustworthy to $sourceDbTrustworthy for $dbName on $destination"
                            }
                            catch {
                                $copyDatabaseStatus.Status = "Successful - failed to apply Trustworthy"
                                $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                                Stop-Function -Message "Failed to update Trustworthy to $sourceDbTrustworthy for $dbName on $destination." -Target $destination -ErrorRecord $_ -Continue
                            }
                        }
                    }

                    if ($sourceDbBrokerEnabled -ne $destServer.Databases[$dbName].BrokerEnabled) {
                        if ($Pscmdlet.ShouldProcess($destination, "Updating BrokerEnabled on $dbName")) {
                            try {
                                $destServer.Databases[$dbName].BrokerEnabled = $sourceDbBrokerEnabled
                                $destServer.Databases[$dbName].Alter()
                                Write-Message -Level Verbose -Message "Successfully updated BrokerEnabled to $sourceDbBrokerEnabled for $dbName on $destination."
                            }
                            catch {
                                $copyDatabaseStatus.Status = "Successful - failed to apply BrokerEnabled"
                                $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                                Stop-Function -Message "Failed to update BrokerEnabled to $sourceDbBrokerEnabled for $dbName on $destination." -Target $destination -ErrorRecord $_ -Continue
                            }
                        }
                    }
                }

                if ($sourceDbReadOnly -ne $destServer.Databases[$dbName].ReadOnly -and $NoRecovery -eq $false) {
                    if ($Pscmdlet.ShouldProcess($destination, "Updating ReadOnly status on $dbName")) {
                        $update = Update-SqldbReadOnly -SqlInstance $destServer -dbname $dbName -readonly $sourceDbReadOnly
                        if ($update -eq $true) {
                            Write-Message -Level Verbose -Message "Successfully updated readonly status on $dbName."
                        }
                        else {
                            $copyDatabaseStatus.Status = "Successful - failed to apply ReadOnly."
                            $copyDatabaseStatus | Select-DefaultView -Property DateTime, SourceServer, DestinationServer, Name, Type, Status, Notes -TypeName MigrationObject
                            Stop-Function -Message "Failed to update ReadOnly status on $dbName." -Target $destination -ErrorRecord $_ -Continue
                        }
                    }
                }

                if ($SetSourceOffline -and $sourceServer.databases[$dbName].status -notlike '*offline*') {
                    if ($Pscmdlet.ShouldProcess($destination, "Setting $dbName offline on $source")) {
                        Stop-DbaProcess -SqlInstance $sourceServer -Database $dbName
                        Set-DbaDatabaseState -SqlInstance $sourceServer -SqlCredential $SourceSqlCredential -database $dbName -Offline
                    }
                }

                if ($Pscmdlet.ShouldProcess("console", "Showing elapsed time")) {
                    $dbTotalTime = $dbFinish - $dbStart
                    $dbTotalTime = ($dbTotalTime.ToString().Split(".")[0])

                    Write-Message -Level Verbose -Message "Finished: $dbFinish."
                    Write-Message -Level Verbose -Message "Elapsed time: $dbTotalTime."
                }
            } # end db by db processing
        }
    }
    end {
        if (Test-FunctionInterrupt) { return }

        if ($Pscmdlet.ShouldProcess("console", "Showing migration time elapsed")) {
            if ($null -ne $elapsed) {

                $totalTime = ($elapsed.Elapsed.toString().Split(".")[0])

                Write-Message -Level Verbose -Message "`nDatabase migration finished"
                Write-Message -Level Verbose -Message "Migration started: $started"
                Write-Message -Level Verbose -Message "Migration completed: $(Get-Date)"
                Write-Message -Level Verbose -Message "Total Elapsed time: $totalTime"

                if ($NetworkShare.length -gt 0 -and $NoBackupCleanup) {
                    Write-Message -Level Verbose -Message "Backups still exist at $NetworkShare."
                }
            }
            else {
                Write-Message -Level Verbose -Message "No work was done, as we stopped during setup phase"
            }
        }
    }
}
